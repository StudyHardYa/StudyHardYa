<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="RabiitMQ, 好好学习Blog">
    <meta name="description" content="RabbitMQ1.1.1. 什么是MQMQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>RabiitMQ | 好好学习Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/loading.css">

<meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>




<body>
    <!-- 页面加载 -->
    
<!-- 页面加载动画 -->

    <div id="loading-box">
      <div class="loading-left-bg"></div>
      <div class="loading-right-bg"></div>
      <div class="spinner-box">
        <div class="configure-border-1">
          <div class="configure-core"></div>
        </div>
        <div class="configure-border-2">
          <div class="configure-core"></div>
        </div>
        <div class="loading-word">加载中...</div>
      </div>
    </div>
    <!-- 页面加载动画 -->
    <script>
      $(document).ready(function () {
        document.body.style.overflow = 'auto';
        document.getElementById('loading-box').classList.add("loaded")
      })
    </script>
  
 

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">好好学习Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于我</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">好好学习Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于我
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/19.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">RabiitMQ</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/java/">
                                <span class="chip bg-color">java</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="post-category">
                                消息队列
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-03-25
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-04-14
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    30.8k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="1-1-1-什么是MQ"><a href="#1-1-1-什么是MQ" class="headerlink" title="1.1.1. 什么是MQ"></a>1.1.1. 什么是MQ</h2><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。 </p>
<h2 id="1-1-2-为什么要用MQ"><a href="#1-1-2-为什么要用MQ" class="headerlink" title="1.1.2. 为什么要用MQ"></a>1.1.2. 为什么要用MQ</h2><p>1.流量消峰 </p>
<p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。 </p>
<p>2.应用解耦 </p>
<p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p>
<p><img src="https://s2.loli.net/2022/04/14/PUA2BNTktKqFE7p.png" alt="image-20220325095640537"></p>
<p>3.异步处理<br>有些服务间调用是异步的，例如A调用B，B需要花费很长时间执行，但是A需要知道B什么时候可以执行完，以前一般有两种方式，A过一段时间去调用B的查询api查询。或者A提供一个callback api,B执行完之后调用api通知A服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题,A调用B服务后，只需要监听B处理完成的消息，当B处理完成后，会发送一条消息给MQ，MQ会将此消息转发给A服务。这样A服务既不用循环调用B的查询api，也不用提供callback api。同样B服务也不用做这些操作。A服务还能及时的得到异步处理成功的消息。</p>
<p><img src="https://s2.loli.net/2022/04/14/LAx2nasguGfTRqK.png" alt="image-20220325095845337"></p>
<h2 id="RabbitMQ工作原理："><a href="#RabbitMQ工作原理：" class="headerlink" title="RabbitMQ工作原理："></a>RabbitMQ工作原理：</h2><p>这张图就是RabbitMQ的工作原理了，我们的代码都会以这个方式进行编码，</p>
<p><img src="https://s2.loli.net/2022/04/14/msSCn9D3fjh4QZH.png" alt="image-20220326144223717"></p>
<p><strong>Broker</strong>:接收和分发消息的应用，RabbitMQ Server 就是 Message Broker<br><strong>Virtual host</strong>:出于多租户和安全因素设计的，把 AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange / queue 等<br><strong>Connection</strong> : publisher / consumer和broker之间的TCP连接<br><strong>Channel</strong>:如果每一次访问RabbitMQ都建立一个 Connection，在消息量大的时候建立TCP<br>Connection的开销将是巨大的，效率也较低。Channel是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，AMQP method包含了channel id帮助客户端和message broker识别channel，所以 channel之间是完全隔离的。Channel作为轻量级的<br>Connection极大减少了操作系统建立TCP connection的开销<br><strong>Exchange</strong>: message到达 broker 的第一站，根据分发规则，匹配查询表中的routing key，分发消息到queue中去。常用的类型有: direct (point-to-point), topic(publish-subscribe) and fanout<br>(multicast)<br><strong>Queue</strong>:消息最终被送到这里等待consumer 取走<br><strong>Binding</strong>: exchange和queue之间的虚拟连接，binding 中可以包含routing key，Binding信息被保存到exchange 中的查询表中，用于message 的分发依据</p>
<h2 id="依赖："><a href="#依赖：" class="headerlink" title="依赖："></a>依赖：</h2><pre class="language-none"><code class="language-none">    &lt;dependencies&gt;

&lt;!--        rabbitmq依赖 客户端--&gt;
        &lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
            &lt;version&gt;5.14.2&lt;/version&gt;
        &lt;/dependency&gt;

&lt;!--        io 文件操作流依赖  --&gt;
        &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-io&lt;/groupId&gt;
            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
            &lt;version&gt;2.11.0&lt;/version&gt;
        &lt;/dependency&gt;


    &lt;/dependencies&gt;</code></pre>





<h2 id="使用的工具类："><a href="#使用的工具类：" class="headerlink" title="使用的工具类："></a>使用的工具类：</h2><pre class="language-none"><code class="language-none">/**
 * RabbitMQ工具类
 */
public class RabbitMQUtil {

    //创建连接工厂 ，这个Rabbit提供的工厂方法，用于获取RabbitMQ的连接
    private static  ConnectionFactory rabbitmqConnFactory = new ConnectionFactory();

    static {
        //RabbitMQ 连接地址
        rabbitmqConnFactory.setHost("124.223.79.104");

        //RabbitMQ 用户名
        rabbitmqConnFactory.setUsername("admin");

        //RabbitMQ 密码
        rabbitmqConnFactory.setPassword("Admin123");
    }

    public static Channel getChannel() throws IOException, TimeoutException {
        //获取RabbitMQ的连接
        Connection connection = rabbitmqConnFactory.newConnection();

        //我们需要使用连接先获取（创建）信道
        return connection.createChannel();
    }
}</code></pre>





<pre class="language-none"><code class="language-none">/**
 * 线程睡眠
 */
public class SleepingUtil {

    public static void sleep(int ss){
        try {
            Thread.sleep(ss*1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}</code></pre>





<h2 id="简单队列使用："><a href="#简单队列使用：" class="headerlink" title="简单队列使用："></a>简单队列使用：</h2><p>简单队列使用如图：</p>
<p><img src="https://s2.loli.net/2022/04/14/3klpcSaY6gftxCJ.png" alt="image-20220326235714086"></p>
<h3 id="生产者："><a href="#生产者：" class="headerlink" title="生产者："></a>生产者：</h3><p>生产者需要将消息放入队列，以便消费者消费</p>
<pre class="language-java" data-language="java"><code class="language-java">/**
 * 生产者
 */
public class Producer {

    private final static String QUEUE_NAME = "hello";

    //记得关闭防火墙或者打开 5672端口，这里测试使用的是5672端口号，否则可能报超时错误
    public static void main(String[] args) throws IOException, TimeoutException {
        //创建连接工厂 ，这个Rabbit提供的工厂方法，用于获取RabbitMQ的连接
        ConnectionFactory rabbitmqConnFactory = new ConnectionFactory();

        //RabbitMQ 连接地址
        rabbitmqConnFactory.setHost("124.223.79.104");

        //RabbitMQ 用户名
        rabbitmqConnFactory.setUsername("admin");

        //RabbitMQ 密码
        rabbitmqConnFactory.setPassword("Admin123");

        //获取RabbitMQ的连接
        Connection connection = rabbitmqConnFactory.newConnection();

        //我们需要使用连接先获取（创建）信道
        Channel channel = connection.createChannel();

        //使用信道调取一个队列的声明（生成队列），我们可以先不创建交换机，默认就会有一个交换机
        //参数：
        // 1、队列的名称
        // 2,队列里的消息是否需要持久化（存储磁盘），默认存储内存中
        // 3,是否需要排它 ， 该队列是否只提供给一个消费者进行消费 是否进行共享 ，true:只能一个消费者消费 false:可以多个消费者消费
        // 4、是否自动删除 ， 最后一个消费者断开连接后，该队列是否自动删除
        // 5、队列参数
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        //发送信息
        String message = "Hello Word";

        //使用信道发送消息
        //参数： 1、 发送到哪个交换机，我们没有创建交换机，填写空就行
        // 2、路由的key值是哪个 本次是队列名称
        // 3、其他参数消息
        // 4、发送的消息体
        channel.basicPublish("",QUEUE_NAME,null,message.getBytes());
        System.out.println("消息发送完毕");


  		channel.close();
        connection.close();


    }

}</code></pre>

<p><strong>运行后：</strong></p>
<p>我们可以使用RabbitMQ的网页查看一些基本信息</p>
<p><img src="https://s2.loli.net/2022/04/14/nEDbfAwR85xXY1I.png" alt="image-20220326144754170"></p>
<h3 id="消费者："><a href="#消费者：" class="headerlink" title="消费者："></a>消费者：</h3><p>获取队列中的消息</p>
<pre class="language-none"><code class="language-none">/**
 * 消费者
 */
public class Consumer {

    private final static String QUEUE_NAME = "hello";

    public static void main(String[] args) throws IOException, TimeoutException {
        //创建连接工厂 ，这个Rabbit提供的工厂方法，用于获取RabbitMQ的连接
        ConnectionFactory rabbitmqConnFactory = new ConnectionFactory();

        //RabbitMQ 连接地址
        rabbitmqConnFactory.setHost("124.223.79.104");

        //RabbitMQ 用户名
        rabbitmqConnFactory.setUsername("admin");

        //RabbitMQ 密码
        rabbitmqConnFactory.setPassword("Admin123");

        //创建连接
        Connection connection = rabbitmqConnFactory.newConnection();

        //创建信道
        Channel channel = connection.createChannel();

        //成功后回调用的类
        DeliverCallback deliverCallback =new DeliverCallback() {
            /**
             *  回调方法
             * @param s  名称
             * @param delivery 获取到队列中消息内容，《getBody()方法获取消息体》
             * @throws IOException
             */
            public void handle(String s, Delivery delivery) throws IOException {
                System.out.println(s+"--&gt;成功");
                System.out.println(new String(delivery.getBody())+"--&gt;成功");
            }
        };

        //取消后回调用的类
        CancelCallback cancelCallback =new CancelCallback() {
            public void handle(String s) throws IOException {
                System.out.println(s+"--&gt;消息被中断，取消");
            }
        };

        //消费者消费（获取对列消息）
        //参数:
        //1,消费哪个对象
        //2,消费成功后是否自动应答  true：自动应答  false：手动应答
        //     应答作用：消费者发送一个消息应答，告诉RabbitMQ这个消息已经接收并且处理完毕了。RabbitMQ就可以删除它了。
        //3,消费者成功消费的回调方法
        //4，消费者取消消费的回调方法
        channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);
        
        
  		channel.close();
        connection.close();
    }
}</code></pre>

<p>运行后：</p>
<p>我们放入的信息被消费了</p>
<p><img src="https://s2.loli.net/2022/04/14/3TERzbSVC1QBIvA.png" alt="image-20220326145001090"></p>
<h2 id="工作队列（Work-Queues）："><a href="#工作队列（Work-Queues）：" class="headerlink" title="工作队列（Work Queues）："></a>工作队列（Work Queues）：</h2><p>一个生产者，一个消息队列，多个消费者，同样也称为点对点模式</p>
<p>工作队列模式的最大特点就是有多个消费者，这样就不会因为处理耗时的任务导致<code>MQ</code>不可用。</p>
<p><img src="https://s2.loli.net/2022/04/14/uOFcwaWS6GJNMU8.png" alt="image-20220327000635100"></p>
<p>默认情况下，<code>rabbitmq</code>将会按顺序派发每个任务给下一个消费者，平均而言，每个消费者将获得相同数量的消息，这种分发消息的方式称为<strong>轮询</strong>。</p>
<h3 id="生产者：-1"><a href="#生产者：-1" class="headerlink" title="生产者："></a>生产者：</h3><pre class="language-none"><code class="language-none">/**
 * 生产者
 */
public class TaskProducer {

    private static final String QUEUE_NAME = "hello";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMQUtil.getChannel();

        //使用信道调取一个队列的声明（生成队列），我们可以先不创建交换机，默认就会有一个交换机
        //参数：
        // 1、队列的名称
        // 2,队列里的消息是否需要持久化（存储磁盘），默认存储内存中
        // 3,是否需要排它 ， 该队列是否只提供给一个消费者进行消费 是否进行共享 ，true:只能一个消费者消费 false:可以多个消费者消费
        // 4、是否自动删除 ， 最后一个消费者断开连接后，该队列是否自动删除
        // 5、队列参数
        channel.queueDeclare(QUEUE_NAME,false,false,false,null);

        //使用控制台输入，我们就可以更换的观察每个信息被谁消费
        Scanner scanner = new Scanner(System.in);

        while (scanner.hasNext()){
            String message = scanner.next();
            channel.basicPublish("",QUEUE_NAME,null,message.getBytes());
            System.out.println(message +" ---&gt; 发送完成");
        }


    }

}</code></pre>





<h3 id="消费者：-1"><a href="#消费者：-1" class="headerlink" title="消费者："></a>消费者：</h3><p>由于要有多个消费者，我们这就使用多线程了</p>
<h4 id="Runnable实现类："><a href="#Runnable实现类：" class="headerlink" title="Runnable实现类："></a>Runnable实现类：</h4><pre class="language-none"><code class="language-none">/**
 * 工作线程， 也就是消费者
 */
public class Worker implements Runnable {

    //队列名称
    private static final String QUEUE_NAME = "hello";

    //消费者名称
    private String name;

    public Worker(String name){
        this.name = name;
    }

    public void run() {
        //获取信道
        Channel channel = null;
        try {
            channel = RabbitMQUtil.getChannel();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }


        //成功获取生产者信息回调方法
        DeliverCallback deliverCallback = new DeliverCallback() {
            public void handle(String s, Delivery delivery) throws IOException {
                System.out.println(new String(delivery.getBody()));
                System.out.println(name+" --&gt;成功");

            }
        };


        // 消费者取消消费的回调方法
        CancelCallback cancelCallback = new CancelCallback() {
            public void handle(String s) throws IOException {
                System.out.println(Thread.currentThread().getName()+"---&gt; " +s + ":消费者取消消费 回调函数  逻辑代码....");
            }
        };

        //消费者消费（获取对列消息）
        //参数:
        //1,消费哪个对象
        //2,消费成功后是否自动应答  true：自动应答  false：手动应答
        //     应答作用：消费者发送一个消息应答，告诉RabbitMQ这个消息已经接收并且处理完毕了。RabbitMQ就可以删除它了。
        //3,消费者成功消费的回调方法
        //4，消费者取消消费的回调方法
        try {
            channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);

            System.out.println(name +" 等待消费");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>





<h4 id="创建消费者线程类："><a href="#创建消费者线程类：" class="headerlink" title="创建消费者线程类："></a>创建消费者线程类：</h4><pre class="language-none"><code class="language-none">/**
 * 创建多个消费者，看看它们轮询消费
 */
public class WorkerText {
    public static void main(String[] args) {

        //继承了Runnable
        // 由于我们创建线程，线程结束后信依旧存活，
        // 但我们的线程名称在回调方法中不能显示我们设置的，所以我们使用这个方式
        Worker worker1 =  new Worker("消费者1");
        Worker worker2 =  new Worker("消费者2");
        Worker worker3 =  new Worker("消费者3");

        //创建多线程
        Thread thread1 = new Thread(worker1);
        thread1.start();

        Thread thread2 = new Thread(worker2);
        thread2.start();

        Thread thread3 = new Thread(worker3);
        thread3.start();


    }
}</code></pre>













<h2 id="应答："><a href="#应答：" class="headerlink" title="应答："></a>应答：</h2><h3 id="消息应答机制"><a href="#消息应答机制" class="headerlink" title="消息应答机制"></a>消息应答机制</h3><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉，由于RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息，以及后续发送给该消费者的消息也无法接收到。</p>
<p>为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制。</p>
<p>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除掉了。</p>
<h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><p>不推荐使用，</p>
<p><strong>RabbitMQ 只要将消息分发给消费者就被认为消息传递成功</strong>,就会将内存中的消息删除,而不管消费者有没有处理完消息</p>
<p>消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡,因为这种模式如果消息在接收到之前，消费者出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</p>
<h3 id="手动消息应答的方法"><a href="#手动消息应答的方法" class="headerlink" title="手动消息应答的方法"></a>手动消息应答的方法</h3><p>推荐使用</p>
<p><strong>RabbitMQ 将消息分发给了消费者,并且只有当消费者处理完成了整个消息之后才会被认为消息传递成功了</strong>,然后才会将内存中的消息删除</p>
<p>Channel.basicAck (用于肯定确认)<br>RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</p>
<p>Channel.basicNack (用于否定确认)<br>Channel.basicReject (用于否定确认)<br>与 Channel.basicNack 相比少一个参数，不处理该消息，直接拒绝，可以将其丢弃了</p>
<h3 id="Multiple-的解释"><a href="#Multiple-的解释" class="headerlink" title="Multiple 的解释"></a><strong>Multiple 的解释</strong></h3><p>手动应答的好处是可以批量应答并且减少网络拥堵 </p>
<p><img src="https://s2.loli.net/2022/04/14/s3yt4HpzagArROm.png" alt="image-20220327182119329"></p>
<p>multiple 的 true 和 false 代表不同意思<strong>（推荐false，虽然可能会导致网络拥堵，但为了避免其它消息可能发生错误导致消息丢失使用不使用批量应答）</strong></p>
<p>true 代表批量应答 channel 上未应答的消息 比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答 </p>
<p>false 同上面相比 只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</p>
<p><img src="https://s2.loli.net/2022/04/14/GcFnwr3djRlVKoZ.png" alt="image-20220327182226782"></p>
<h3 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息 未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者 可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确 保不会丢失任何消息</p>
<p><img src="https://s2.loli.net/2022/04/14/dO3AKMXzWDnHlm5.png" alt="image-20220327183127721"></p>
<h3 id="手动应答测试代码："><a href="#手动应答测试代码：" class="headerlink" title="手动应答测试代码："></a><strong>手动应答测试代码：</strong></h3><h4 id="测试目标："><a href="#测试目标：" class="headerlink" title="测试目标："></a>测试目标：</h4><p>（注意，为确认应答只是RabbitMQ不会删除队列中的消息）</p>
<p>1，观察消费者在消费失败时，消息是否会重新入队并提供给其他消费者消费 (断开连接消息重新入队)</p>
<p>2，观察消费手动应答后队列消息的变化</p>
<h4 id="生产者：-2"><a href="#生产者：-2" class="headerlink" title="生产者："></a><strong>生产者：</strong></h4><p>生产者还是那么回事，主要看消费者</p>
<pre class="language-none"><code class="language-none">/**
 * 生产者  本文件测试应答
 */
public class Producer {

    private static final String QUEUE_NAME = "ack_queue";

    public static void main(String[] args) throws IOException, TimeoutException {

        //获取信道
        Channel channel = RabbitMQUtil.getChannel();
        //使用信道调取一个队列的声明（生成队列），我们可以先不创建交换机，默认就会有一个交换机
        //参数：
        // 1、队列的名称
        // 2,队列里的消息是否需要持久化（存储磁盘），默认存储内存中
        // 3,是否需要排它 ， 该队列是否只提供给一个消费者进行消费 是否进行共享 ，true:只能一个消费者消费 false:可以多个消费者消费
        // 4、是否自动删除 ， 最后一个消费者断开连接后，该队列是否自动删除
        // 5、队列参数
        channel.queueDeclare(QUEUE_NAME,false,false,false,null);

        Scanner scanner = new Scanner(System.in);

        while (scanner.hasNext()){
            String message = scanner.next();

            //使用信道发送消息
            //参数： 1、 发送到哪个交换机，我们没有创建交换机，填写空就行
            // 2、路由的key值是哪个 本次是队列名称
            // 3、其他参数消息
            // 4、发送的消息体
            channel.basicPublish("",QUEUE_NAME,null,message.getBytes());

            System.out.println("发生消息成功 --&gt;&gt; "+message);
        }
    }

}</code></pre>





<h4 id="消费者：-2"><a href="#消费者：-2" class="headerlink" title="消费者："></a>消费者：</h4><p>我们还是使用多线程测试，也可以创建两个消费者main ，我认为比较麻烦，所以使用多线程了</p>
<p> <strong>Runnable实现类：</strong></p>
<p>DeliverCallback中，我编写的是10秒后让消费者2异常终止，这样就可以观察到信道连接中断时，消息是否会重新入队</p>
<pre class="language-none"><code class="language-none">/**
* 消费者代码
 */
public class WorkConsumer implements Runnable{

    private static final String QUEUE_NAME = "ack_queue";

    //消费者名称
    private String name;

    //线程沉睡时间
    private Integer time;

    public WorkConsumer(String name,Integer time){
        this.name = name;
        this.time = time;
    }

    public void run() {

        Channel channel = null;
        try {
            //获取信道
            channel = RabbitMQUtil.getChannel();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }

        System.out.println(name+"等待消息接收时间为 --&gt; "+time +"秒");

        //这是为了让匿名实现类内部能够使用channel
        final Channel finalChannel = channel;
        //消费消息方法
        DeliverCallback deliverCallback = new DeliverCallback() {
            public void handle(String s, Delivery delivery) throws IOException {
                //线程沉睡
                SleepingUtil.sleep(time);

                //用于测试如果代码出问题，那么消息是否会重新入队并且给另一个消费者消费
                if (name.equals("消费者2")){
                    Thread.currentThread().stop();
                }

                System.out.println(name+"消费消息: "+new String(delivery.getBody()));

                //手动应答（确认成功）
                //参数：
                //1、消息的标记 tag，每个消息在信道中都会有标记
                // 我们可以获取到消息中的标记，并手动应答表示这个标记的消息以成功接收
                //delivery.getEnvelope().getDeliveryTag() 这个方法可回去到我们消息中的标记
                //2、是否批量应答 false不批量
                finalChannel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);
            }
        };

        //取消回调方法
        CancelCallback cancelCallback = new CancelCallback() {
            public void handle(String s) throws IOException {
                System.out.println("取消消息成功 --&gt;" +s);
            }
        };


        try {
            //消费者消费（获取对列消息）
            //参数:
            //1,消费哪个对象
            //2,消费成功后是否自动应答  true：自动应答  false：手动应答
            //     应答作用：消费者发送一个消息应答，告诉RabbitMQ这个消息已经接收并且处理完毕了。RabbitMQ就可以删除它了。
            //3,消费者成功消费的回调方法
            //4，消费者取消消费的回调方法
            channel.basicConsume(QUEUE_NAME,false,deliverCallback,cancelCallback);
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}</code></pre>



<p><strong>线程启动类：</strong></p>
<pre class="language-none"><code class="language-none">public class ConsumerThread {

    public static void main(String[] args) {
        WorkConsumer workConsumer1 = new WorkConsumer("消费者1",1);
        WorkConsumer workConsumer2 = new WorkConsumer("消费者2",10);

        Thread thread = new Thread(workConsumer1);
        thread.start();

        Thread thread1 = new Thread(workConsumer2);
        thread1.start();
    }


}</code></pre>





<h4 id="目标结果："><a href="#目标结果：" class="headerlink" title="目标结果："></a>目标结果：</h4><p>1，观察消费者在消费失败时，消息是否会重新入队并提供给其他消费者消费</p>
<p>​        可以得出消费会重新入队并给其他消费者消费</p>
<p><img src="https://s2.loli.net/2022/04/14/A45CnVRQ1EYm97T.png" alt="image-20220328184117474"></p>
<p>2，观察消费手动应答后队列消息的变化（基于以上代码在手动应答删除情况下进行）</p>
<p>​                可看到，队列消息还在其他，并没有删除</p>
<p><img src="https://s2.loli.net/2022/04/14/SCBcLwit1RIXbWN.png" alt="image-20220328184449413"></p>
<p><img src="https://s2.loli.net/2022/04/14/CZqWAfh6YQ3To4P.png" alt="image-20220328184452126"></p>
<h2 id="持久化："><a href="#持久化：" class="headerlink" title="持久化："></a>持久化：</h2><h3 id="队列持久化："><a href="#队列持久化：" class="headerlink" title="队列持久化："></a>队列持久化：</h3><p>持久化队列后，当我们重启RabbitMQ时，队列不会消失（注意：是队列不是消息）</p>
<p><strong>如何持久化？</strong></p>
<p>我们只需要在声明（创建）队列时将参数二改为true即可</p>
<pre class="language-none"><code class="language-none">//获取信道
Channel channel = RabbitMQUtil.getChannel();
//使用信道调取一个队列的声明（生成队列），我们可以先不创建交换机，默认就会有一个交换机
//参数：
// 1、队列的名称
// 2,队列里的消息是否需要持久化（存储磁盘），默认存储内存中
// 3,是否需要排它 ， 该队列是否只提供给一个消费者进行消费 是否进行共享 ，true:只能一个消费者消费 false:可以多个消费者消费
// 4、是否自动删除 ， 最后一个消费者断开连接后，该队列是否自动删除
// 5、队列参数
channel.queueDeclare(QUEUE_NAME,true,false,false,null);</code></pre>



<h4 id="判断队列是否持久化："><a href="#判断队列是否持久化：" class="headerlink" title="判断队列是否持久化："></a>判断队列是否持久化：</h4><p><img src="https://s2.loli.net/2022/04/14/YLjTF5XOqBQxMw1.png" alt="image-20220328233855919"></p>
<h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a><strong>注意点：</strong></h4><p>以及声明（创建）过的队列是不能持久化的，要删除后重新声明时才能设置为持久化</p>
<p><strong>为以及存在的队列持久化报错异常：</strong></p>
<pre class="language-none"><code class="language-none">Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - inequivalent arg 'durable' for queue 'ack_queue' in vhost '/': received 'true' but current is 'false', class-id=50, method-id=10)
	at com.rabbitmq.client.impl.ChannelN.asyncShutdown(ChannelN.java:517)
	at com.rabbitmq.client.impl.ChannelN.processAsync(ChannelN.java:341)
	at com.rabbitmq.client.impl.AMQChannel.handleCompleteInboundCommand(AMQChannel.java:182)
	at com.rabbitmq.client.impl.AMQChannel.handleFrame(AMQChannel.java:114)
	at com.rabbitmq.client.impl.AMQConnection.readFrame(AMQConnection.java:739)
	at com.rabbitmq.client.impl.AMQConnection.access$300(AMQConnection.java:47)
	at com.rabbitmq.client.impl.AMQConnection$MainLoop.run(AMQConnection.java:666)
	at java.lang.Thread.run(Thread.java:748)

</code></pre>

<p><strong>解决方法：</strong></p>
<p>删除队列，重新声明</p>
<p><img src="https://s2.loli.net/2022/04/14/1vrfuRqKHQyjM5B.png" alt="image-20220328233921944"></p>
<p><img src="https://s2.loli.net/2022/04/14/SysX5Ea4tUGR2vY.png" alt="image-20220328233926734"></p>
<h4 id="消息持久化："><a href="#消息持久化：" class="headerlink" title="消息持久化："></a>消息持久化：</h4><p>要想让消息实现持久化需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN 添 加这个属性。</p>
<p><img src="https://s2.loli.net/2022/04/14/LmWC2N5HGZEf7X8.png" alt="image-20220328234328144"></p>
<p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是 这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要 更强有力的持久化策略，参考发布确认。</p>
<h2 id="不公平分发消息："><a href="#不公平分发消息：" class="headerlink" title="不公平分发消息："></a>不公平分发消息：</h2><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p>
<p>为了避免上述情况，强烈建议使用不公平分发（能者多劳）,这样速度快的消费者就可以消费多个不会闲置。</p>
<p>不公平分发消息 消费者需要设置信道参数： <strong>channel.basicQos(1);</strong>   <strong>1是不公平分发   ， 默认是 0 轮询分发</strong>   <strong>而 2-5则是预取值</strong></p>
<h3 id="生产者：-3"><a href="#生产者：-3" class="headerlink" title="生产者："></a>生产者：</h3><pre class="language-none"><code class="language-none">
/**
 * 生产者  本文件测试应答
 */
public class Producer {

    private static final String QUEUE_NAME = "ack_queue";

    public static void main(String[] args) throws IOException, TimeoutException {

        //获取信道
        Channel channel = RabbitMQUtil.getChannel();
        //使用信道调取一个队列的声明（生成队列），我们可以先不创建交换机，默认就会有一个交换机
        //参数：
        // 1、队列的名称
        // 2,队列里的消息是否需要持久化（存储磁盘），默认存储内存中
        // 3,是否需要排它 ， 该队列是否只提供给一个消费者进行消费 是否进行共享 ，true:只能一个消费者消费 false:可以多个消费者消费
        // 4、是否自动删除 ， 最后一个消费者断开连接后，该队列是否自动删除
        // 5、队列参数
        channel.queueDeclare(QUEUE_NAME,true,false,false,null);

        Scanner scanner = new Scanner(System.in);

        while (scanner.hasNext()){
            String message = scanner.next();

            //使用信道发送消息
            //参数： 1、 发送到哪个交换机，我们没有创建交换机，填写空就行
            // 2、路由的key值是哪个 本次是队列名称
            // 3、其他参数消息
            // 4、发送的消息体
            channel.basicPublish("",QUEUE_NAME,null,message.getBytes());

            System.out.println("发生消息成功 --&gt;&gt; "+message);
        }
    }

}
</code></pre>





<h3 id="消费者：-3"><a href="#消费者：-3" class="headerlink" title="消费者："></a>消费者：</h3><h4 id="Runnable实现类：-1"><a href="#Runnable实现类：-1" class="headerlink" title="Runnable实现类："></a>Runnable实现类：</h4><pre class="language-none"><code class="language-none">/**
* 消费者代码
 */
public class WorkConsumer implements Runnable{

    private static final String QUEUE_NAME = "ack_queue";

    //消费者名称
    private String name;

    //线程沉睡时间
    private Integer time;

    public WorkConsumer(String name,Integer time){
        this.name = name;
        this.time = time;
    }

    public void run() {

        Channel channel = null;
        try {
            //获取信道
            channel = RabbitMQUtil.getChannel();
            //开启不公平分发
            channel.basicQos(1);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }

        System.out.println(name+"等待消息接收时间为 --&gt; "+time +"秒");

        //这是为了让匿名实现类内部能够使用channel
        final Channel finalChannel = channel;
        //消费消息方法
        DeliverCallback deliverCallback = new DeliverCallback() {
            public void handle(String s, Delivery delivery) throws IOException {
                System.out.println(name+"开始消费");
                //线程沉睡
                SleepingUtil.sleep(time);

                //用于测试如果代码出问题，那么消息是否会重新入队并且给另一个消费者消费
//                if (name.equals("消费者2")){
//                    System.out.println("消费者2，死亡，连接断开...");
//                    Thread.currentThread().stop();
//                }

                System.out.println(name+"消费消息: "+new String(delivery.getBody()));

                //手动应答（确认成功）
                //参数：
                //1、消息的标记 tag，每个消息在信道中都会有标记
                // 我们可以获取到消息中的标记，并手动应答表示这个标记的消息以成功接收
                //delivery.getEnvelope().getDeliveryTag() 这个方法可回去到我们消息中的标记
                //2、是否批量应答 false不批量
                finalChannel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);
            }
        };

        //取消回调方法
        CancelCallback cancelCallback = new CancelCallback() {
            public void handle(String s) throws IOException {
                System.out.println("取消消息成功 --&gt;" +s);
            }
        };


        try {
            //消费者消费（获取对列消息）
            //参数:
            //1,消费哪个对象
            //2,消费成功后是否自动应答  true：自动应答  false：手动应答
            //     应答作用：消费者发送一个消息应答，告诉RabbitMQ这个消息已经接收并且处理完毕了。RabbitMQ就可以删除它了。
            //3,消费者成功消费的回调方法
            //4，消费者取消消费的回调方法
            channel.basicConsume(QUEUE_NAME,false,deliverCallback,cancelCallback);
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}</code></pre>



<h4 id="消费者线程执行类："><a href="#消费者线程执行类：" class="headerlink" title="消费者线程执行类："></a>消费者线程执行类：</h4><pre class="language-none"><code class="language-none">public class ConsumerThread {

    public static void main(String[] args) {
        WorkConsumer workConsumer1 = new WorkConsumer("消费者1",1);
        WorkConsumer workConsumer2 = new WorkConsumer("消费者2",10);

        Thread thread = new Thread(workConsumer1);
        thread.start();

        Thread thread1 = new Thread(workConsumer2);
        thread1.start();
    }


}</code></pre>





<h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><p>可观察到，消费者1因为消费快所以消费的多，而消费者2消费慢就消费的少</p>
<p><img src="https://s2.loli.net/2022/04/14/PoORgnj7HIQTku1.png" alt="image-20220329101724499"></p>
<h2 id="预取值"><a href="#预取值" class="headerlink" title="预取值"></a>预取值</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能限制此 缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有 未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何 消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高 向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器)应该小心使用具有无限预处理 的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。当然这 将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p>
<p>简单说就是在信道中设置一个缓冲区，从队列中获取消息放入信道缓冲区中，信道中的消息是不会被别的消费者获取，<strong>最多预取值存放5条消息在信道中</strong></p>
<p><strong>设置预取值：channel.basicQos(5);  参数为 2 - 5 ；表示预取值的数量</strong></p>
<p><strong>它是分配是这样的：</strong></p>
<p>队列会先将他们的信道中预取值填充完，之后谁空缺给谁补充，如14条消息，消费者1消费时间为1秒预取值为3，消费者2消费时间为10秒，预取值为5，那么会先被消费者1，2分别拿走3,5条，但由于消费者1消费的快，将缓冲区（预取值）中消息消费了，那么队列就会为消费者1补充，最终，消费者1消费者了6条消息后，消费者2才消费1条它缓冲区的一条消息，但由于消费者1已经将消息消费完了，那么就没有消息为消费者2补充了，如果再来了一条消息，也就随机在两个消费者中选一个补充</p>
<p><img src="https://s2.loli.net/2022/04/14/m57s3d1opthzugq.png" alt="image-20220329104154264"></p>
<h3 id="生产者：-4"><a href="#生产者：-4" class="headerlink" title="生产者："></a>生产者：</h3><pre class="language-none"><code class="language-none">/**
 * 生产者  本文件测试应答
 */
public class Producer {

    private static final String QUEUE_NAME = "ack_queue";

    public static void main(String[] args) throws IOException, TimeoutException {

        //获取信道
        Channel channel = RabbitMQUtil.getChannel();
        //使用信道调取一个队列的声明（生成队列），我们可以先不创建交换机，默认就会有一个交换机
        //参数：
        // 1、队列的名称
        // 2,队列里的消息是否需要持久化（存储磁盘），默认存储内存中
        // 3,是否需要排它 ， 该队列是否只提供给一个消费者进行消费 是否进行共享 ，true:只能一个消费者消费 false:可以多个消费者消费
        // 4、是否自动删除 ， 最后一个消费者断开连接后，该队列是否自动删除
        // 5、队列参数
        channel.queueDeclare(QUEUE_NAME,true,false,false,null);

        Scanner scanner = new Scanner(System.in);

        while (scanner.hasNext()){
            String message = scanner.next();

            //使用信道发送消息
            //参数： 1、 发送到哪个交换机，我们没有创建交换机，填写空就行
            // 2、路由的key值是哪个 本次是队列名称
            // 3、其他参数消息
            // 4、发送的消息体
            channel.basicPublish("",QUEUE_NAME,null,message.getBytes());

            System.out.println("发生消息成功 --&gt;&gt; "+message);
        }
    }

}</code></pre>



<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者:"></a>消费者:</h3><p>要在队列持久化下进行</p>
<h4 id="Runnable实现类：-2"><a href="#Runnable实现类：-2" class="headerlink" title="Runnable实现类："></a>Runnable实现类：</h4><pre class="language-none"><code class="language-none">/**
* 消费者代码
 */
public class WorkConsumer implements Runnable{

    private static final String QUEUE_NAME = "ack_queue";

    //消费者名称
    private String name;

    //线程沉睡时间
    private Integer time;

    //预取值
    private  Integer forecast;

    public WorkConsumer(String name,Integer time,Integer forecast){
        this.name = name;
        this.time = time;
        this.forecast=forecast;
    }

    public void run() {

        Channel channel = null;
        try {
            //获取信道
            channel = RabbitMQUtil.getChannel();
            //设置预取值的数量，（1是不公平，0是轮询，2-5才是预取值）
            channel.basicQos(forecast);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }

        System.out.println(name+"等待消息接收时间为 --&gt; "+time +"秒");

        //这是为了让匿名实现类内部能够使用channel
        final Channel finalChannel = channel;
        //消费消息方法
        DeliverCallback deliverCallback = new DeliverCallback() {
            public void handle(String s, Delivery delivery) throws IOException {
                System.out.println(name+"开始消费");
                //线程沉睡
                SleepingUtil.sleep(time);

                //用于测试如果代码出问题，那么消息是否会重新入队并且给另一个消费者消费
//                if (name.equals("消费者2")){
//                    System.out.println("消费者2，死亡，连接断开...");
//                    Thread.currentThread().stop();
//                }

                System.out.println(name+"消费消息: "+new String(delivery.getBody()));

                //手动应答（确认成功）
                //参数：
                //1、消息的标记 tag，每个消息在信道中都会有标记
                // 我们可以获取到消息中的标记，并手动应答表示这个标记的消息以成功接收
                //delivery.getEnvelope().getDeliveryTag() 这个方法可回去到我们消息中的标记
                //2、是否批量应答 false不批量
                finalChannel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);
            }
        };

        //取消回调方法
        CancelCallback cancelCallback = new CancelCallback() {
            public void handle(String s) throws IOException {
                System.out.println("取消消息成功 --&gt;" +s);
            }
        };


        try {
            //消费者消费（获取对列消息）
            //参数:
            //1,消费哪个对象
            //2,消费成功后是否自动应答  true：自动应答  false：手动应答
            //     应答作用：消费者发送一个消息应答，告诉RabbitMQ这个消息已经接收并且处理完毕了。RabbitMQ就可以删除它了。
            //3,消费者成功消费的回调方法
            //4，消费者取消消费的回调方法
            channel.basicConsume(QUEUE_NAME,false,deliverCallback,cancelCallback);
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}</code></pre>



<h4 id="消费者线程创建类："><a href="#消费者线程创建类：" class="headerlink" title="消费者线程创建类："></a>消费者线程创建类：</h4><pre class="language-none"><code class="language-none">public class ConsumerThread {

    public static void main(String[] args) {
        WorkConsumer workConsumer1 = new WorkConsumer("消费者1",1,3);
        WorkConsumer workConsumer2 = new WorkConsumer("消费者2",10,5);

        Thread thread = new Thread(workConsumer1);
        thread.start();

        Thread thread1 = new Thread(workConsumer2);
        thread1.start();
    }


}</code></pre>



<p>这里就可以看到预取值的测试结果了</p>
<h2 id="发布确认："><a href="#发布确认：" class="headerlink" title="发布确认："></a>发布确认：</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>​    生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的 消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队 列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传 给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p>
<p>​    confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信 道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调 方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消 息，生产者应用程序同样可以在回调方法中处理该 nack 消息</p>
<p><img src="https://s2.loli.net/2022/04/14/HAK7hyTiM4QUgez.png" alt="image-20220330170450998"></p>
<h3 id="开启发布确认的方法："><a href="#开启发布确认的方法：" class="headerlink" title="开启发布确认的方法："></a>开启发布确认的方法：</h3><pre class="language-none"><code class="language-none">//开启发布确认
channel.confirmSelect();
//发布确认等候结果：当服务端（队列）返回false，或超时，生产者可以重新发送消息
channel.waitForConfirms();</code></pre>







<h3 id="单个发布确认："><a href="#单个发布确认：" class="headerlink" title="单个发布确认："></a>单个发布确认：</h3><p>​        这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它 被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认 的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p>
<p>​        这种确认方式有一个最大的缺点就是:发布速度特别的慢，因为如果没有确认发布的消息就会 阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某 些应用程序来说这可能已经足够了。</p>
<h4 id="生产者：-5"><a href="#生产者：-5" class="headerlink" title="生产者："></a>生产者：</h4><p>发布确认是发生在生产者与队列之间的，所以不需要消费者</p>
<p>测试结果结果：发布1000个单独确认消息，耗时：21570毫秒  (加上控制台打印时间)</p>
<pre class="language-none"><code class="language-none">    //单个发布确认（缺点：每发一条消息都需要确认,耗费时间比较长，性能不好）
    public static void SingleReleaseConfirmation() throws IOException, TimeoutException, InterruptedException {

        Channel channel = RabbitMQUtil.getChannel();


        //开启发布确认
        channel.confirmSelect();

        //随机生成一个uuid为队列名称
        String queryName = UUID.randomUUID().toString();

        //使用信道调取一个队列的声明（生成队列），我们可以先不创建交换机，默认就会有一个交换机
        //参数：
        // 1、队列的名称
        // 2,队列里的消息是否需要持久化（存储磁盘），默认存储内存中
        // 3,是否需要排它 ， 该队列是否只提供给一个消费者进行消费 是否进行共享 ，true:只能一个消费者消费 false:可以多个消费者消费
        // 4、是否自动删除 ， 最后一个消费者断开连接后，该队列是否自动删除
        // 5、队列参数
        channel.queueDeclare(queryName,true,false,false,null);


        //开始时间
        long l = System.currentTimeMillis();
		
		//批量发送消息，单独确认
        for (Integer i=0;i&lt;MESSAGE_COUNT;i++){

            //使用信道发送消息
            //参数： 1、 发送到哪个交换机，我们没有创建交换机，填写空就行
            // 2、路由的key值是哪个 本次是队列名称
            // 3、其他参数消息
            // 4、发送的消息体
            channel.basicPublish("",queryName,null,i.toString().getBytes());
            //发布确认结果：当服务端（队列）返回false，或超时，生产者可以重新发送消息
            boolean b = channel.waitForConfirms();
            if (b){
                System.out.println("消息发布成功");
            }
        }

        long l1 = System.currentTimeMillis();
        System.out.println("发布"+MESSAGE_COUNT+"个单独确认消息，耗时："+ (l1-l) +"毫秒");

    }
}</code></pre>





<h3 id="批量发布确认："><a href="#批量发布确认：" class="headerlink" title="批量发布确认："></a>批量发布确认：</h3><p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地 提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种 方案仍然是同步的，也一样阻塞消息的发布</p>
<h4 id="生产者：-6"><a href="#生产者：-6" class="headerlink" title="生产者："></a>生产者：</h4><p>结果：批量发布确认,发布1000条消息，批量确认消息大小：100，耗时：355毫秒(加上控制台打印时间)</p>
<pre class="language-none"><code class="language-none">//批量确认发布,缺点（当发生故障导致发布出现问题时，不知道是哪个消息出现问题了）
   public static void  batchReleaseConfirmation() throws IOException, TimeoutException, InterruptedException {

       Channel channel = RabbitMQUtil.getChannel();

       //开启发布确认
       channel.confirmSelect();

       String queryName = UUID.randomUUID().toString();
       //使用信道调取一个队列的声明（生成队列），我们可以先不创建交换机，默认就会有一个交换机
       //参数：
       // 1、队列的名称
       // 2,队列里的消息是否需要持久化（存储磁盘），默认存储内存中
       // 3,是否需要排它 ， 该队列是否只提供给一个消费者进行消费 是否进行共享 ，true:只能一个消费者消费 false:可以多个消费者消费
       // 4、是否自动删除 ， 最后一个消费者断开连接后，该队列是否自动删除
       // 5、队列参数
       channel.queueDeclare(queryName,true,false,false,null);


       //批量发布确认的大小
       int ConfirmsMax=100;

       //开始时间
       long l = System.currentTimeMillis();

       //批量发送消息，单独确认
       for (Integer i=0;i&lt;MESSAGE_COUNT;i++){

           //使用信道发送消息
           //参数： 1、 发送到哪个交换机，我们没有创建交换机，填写空就行
           // 2、路由的key值是哪个 本次是队列名称
           // 3、其他参数消息
           // 4、发送的消息体
           channel.basicPublish("",queryName,null,i.toString().getBytes());

           //批量发布确认（没一百条确认一次）
           if ((i+1)%ConfirmsMax==0) {
               //发布确认结果：当服务端（队列）返回false，或超时，生产者可以重新发送消息
               boolean b = channel.waitForConfirms();
               if (b) {
                   System.out.println("消息发布成功");
               }
           }
       }

       long l1 = System.currentTimeMillis();
       System.out.println("发布"+MESSAGE_COUNT+"条消息，批量确认消息大小："+ConfirmsMax+"，耗时："+ (l1-l) +"毫秒");


   }</code></pre>







<h3 id="异步发布确认："><a href="#异步发布确认：" class="headerlink" title="异步发布确认："></a>异步发布确认：</h3><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的</p>
<p><img src="https://s2.loli.net/2022/04/14/4NcUuKtxSIJR2q3.png" alt="image-20220404144939674"></p>
<h4 id="生产者：-7"><a href="#生产者：-7" class="headerlink" title="生产者："></a>生产者：</h4><p>使用方法:(具体看代码，有写注释)<br>          addConfirmListener()消息监听器，监听哪些消息成功，哪些消息失败（有重载，一个参数的只监听成功）<br>          这个方法是异步的<br>          参数:<br>          1、成功确认<br>          2、失败确认</p>
<p>​        参数接口为ConfirmCallback，要我们实例化</p>
<p>ConcurrentSkipListMap为跳表支持高频发：简单放个图看一下</p>
<p><img src="https://s2.loli.net/2022/04/14/G7jTrlm5YnJK4Vv.png" alt="image-20220402142557914"></p>
<p>要了解可以看下这篇文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/p/3498556.html">Java多线程系列–“JUC集合”05之 ConcurrentSkipListMap - 如果天空不死 - 博客园 (cnblogs.com)</a></p>
<p>主要就是使用这个集合存放发送的消息，确认后移出</p>
<p>这个方法，返回此映射的部分视图，其键值严格小于 toKey。<br>                      ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey)</p>
<p>结果： //发布1000条消息，异步发布确认消息，耗时：41毫秒(异步确认)</p>
<pre class="language-none"><code class="language-none">
//异步发布确认
public static void asyncReleaseConfirmation() throws IOException, TimeoutException {



    Channel channel = RabbitMQUtil.getChannel();

    //开启发布确认
    channel.confirmSelect();

    /**
     * 线程完全有序的一个哈希表 使用于高并发的情况下
     * 1，轻松的将序号于消息进行管理
     * 2，轻松批量删除条目 只要给到序号
     * 3，支持高并发（多线程）
     */
    final ConcurrentSkipListMap&lt;Long,String&gt; outstandingConfirms = new ConcurrentSkipListMap&lt;Long, String&gt;();

    String queryName = UUID.randomUUID().toString();
    //使用信道调取一个队列的声明（生成队列），我们可以先不创建交换机，默认就会有一个交换机
    //参数：
    // 1、队列的名称
    // 2,队列里的消息是否需要持久化（存储磁盘），默认存储内存中
    // 3,是否需要排它 ， 该队列是否只提供给一个消费者进行消费 是否进行共享 ，true:只能一个消费者消费 false:可以多个消费者消费
    // 4、是否自动删除 ， 最后一个消费者断开连接后，该队列是否自动删除
    // 5、队列参数
    channel.queueDeclare(queryName,true,false,false,null);
    //开始时间
    long l = System.currentTimeMillis();


    /**
     * 消息确认成功回调
     */
    ConfirmCallback ackCallback = new ConfirmCallback() {
        //参数：1、哪个消息    2、是否为批量确认
        public void handle(long l, boolean b) throws IOException {
            System.out.println("成功发布消息："+l);
            System.out.println("是否为批量确认"+b);

            if (b){

                /**
                 *  批量：删除掉已经确认的消息 剩下的就是为确认的消息
                 *  返回此映射的部分视图，其键值严格小于 toKey。
                 * ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey)
                 *  返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。
                 * ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive)
                 */
                ConcurrentNavigableMap&lt;Long, String&gt; longStringConcurrentNavigableMap = outstandingConfirms.headMap(l);
                NavigableSet&lt;Long&gt; longs = longStringConcurrentNavigableMap.keySet();
                //循环获取的key将它遍历出来如何进行移出
                for (Long aLong : longs) {
                    System.out.println(aLong);

                    outstandingConfirms.remove(aLong);
                }
                //清除
                longStringConcurrentNavigableMap.clear();
            }else {
                //不是批量确认就直接移出就可以了
                outstandingConfirms.remove(l);
            }
        }
    };
    ConfirmCallback nackCallback= new ConfirmCallback() {
        //参数：1、哪个消息    2、是否为批量确认
        public void handle(long l, boolean b) throws IOException {
            System.out.println("失败发布消息："+l);
            System.out.println("是否为批量确认"+b);
        }
    };;

    /**
     * addConfirmListener()消息监听器，监听哪些消息成功，哪些消息失败（有重载，一个参数的只监听成功）
     * 这个方法是异步的
     * 参数:
     * 1、成功确认
     * 2、失败确认
    */
    channel.addConfirmListener(ackCallback,nackCallback);

    //异步发布确认，我们尽管发，由broker将消息的成功失败告诉我们，但我们需要监听器监听
    for (Integer i=0;i&lt;MESSAGE_COUNT;i++){

        String message="消息"+i;

        //使用信道发送消息
        //参数： 1、 发送到哪个交换机，我们没有创建交换机，填写空就行
        // 2、路由的key值是哪个 本次是队列名称
        // 3、其他参数消息
        // 4、发送的消息体
        channel.basicPublish("",queryName,null,i.toString().getBytes());

        //将消息需要于数据放入ConcurrentSkipListMap中，channel.getNextPublishSeqNo()下个发送消息的序号
        outstandingConfirms.put(channel.getNextPublishSeqNo(),message);
    }

    long l1 = System.currentTimeMillis();
    System.out.println("发布"+MESSAGE_COUNT+"条消息，异步发布确认消息，耗时："+ (l1-l) +"毫秒");
}</code></pre>





<h2 id="交换机-Exchanges-："><a href="#交换机-Exchanges-：" class="headerlink" title="交换机(Exchanges)："></a>交换机(Exchanges)：</h2><h3 id="交换机的作用："><a href="#交换机的作用：" class="headerlink" title="交换机的作用："></a>交换机的作用：</h3><p>可以用于发布订阅模式，由于我们使用默认交换机时，我们的多个消费者是竞争关系，一个消息只会被消费一次，当我们使用交换机可以实现绑定多个队列实现一个消息消费多次</p>
<p><img src="https://s2.loli.net/2022/04/14/mGudoX98wLMvcIp.png" alt="image-20220404145939041"></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h3><p>RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产 者甚至都不知道这些消息传递传递到了哪些队列中。生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来 自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消 息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p>
<h3 id="交换机-Exchanges-类型"><a href="#交换机-Exchanges-类型" class="headerlink" title="交换机(Exchanges)类型:"></a>交换机(Exchanges)类型:</h3><p><strong>总共有以下类型：</strong> </p>
<p>路由类型：直接(direct),    </p>
<p>主题类型(topic) ,   </p>
<p>头类型：标题(headers) ,  </p>
<p> 发布订阅类型： 扇出(fanout)</p>
<h3 id="无名交换机（exchange）"><a href="#无名交换机（exchange）" class="headerlink" title="无名交换机（exchange）"></a>无名交换机（exchange）</h3><p>前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。</p>
<pre class="language-none"><code class="language-none">channel.basicPublish("",QUEUE_NAME,null,message.getBytes());</code></pre>

<p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机</p>
<p>消息能发送到队列中其实 是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话，</p>
<p>没有可以使用队列名称，使用创建的交换机时要绑定队列的routingKey(bindingkey)，bindingkey是队列的key，可以自己取名的（队列默认binding就是队列名称）</p>
<h3 id="临时队列："><a href="#临时队列：" class="headerlink" title="临时队列："></a>临时队列：</h3><p>没有持久化的队列就是临时队列</p>
<p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称 的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连 接，队列将被自动删除。</p>
<p>创建临时队列的方式如下:</p>
<p>​    String queueName = channel.queueDeclare().getQueue();</p>
<p>创建出来之后长成这样:</p>
<p><img src="https://s2.loli.net/2022/04/14/zYrdGTwJDHSjtb3.png" alt="image-20220404200129888"></p>
<h3 id="绑定-bindings-："><a href="#绑定-bindings-：" class="headerlink" title="绑定(bindings)："></a>绑定(bindings)：</h3><p>什么是 bingding 呢，binding 其实是 交换机（exchange） 和 队列（queue） 之间的桥梁，它告诉我们 交换机（exchange） 和 哪个队 列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑</p>
<p>简单说就是，交换机绑定队列的bindingkey，绑定后交换机就可以把消息放入绑定的队列中</p>
<p><img src="https://s2.loli.net/2022/04/14/Pwmui8EXOjas67A.png" alt="image-20220404200257614"></p>
<h3 id="发布订阅（fanout）："><a href="#发布订阅（fanout）：" class="headerlink" title="发布订阅（fanout）："></a>发布订阅（fanout）：</h3><h4 id="Fanout-介绍："><a href="#Fanout-介绍：" class="headerlink" title="Fanout 介绍："></a>Fanout 介绍：</h4><p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息<strong>广播</strong>到它知道的所有队列中。</p>
<p>系统中默认有的exchange 类型：</p>
<p><img src="https://s2.loli.net/2022/04/14/KWIwfl6CJ24es8g.png" alt="image-20220405141041791"></p>
<h4 id="Fanout-示例："><a href="#Fanout-示例：" class="headerlink" title="Fanout 示例："></a>Fanout 示例：</h4><h5 id="大致实现图："><a href="#大致实现图：" class="headerlink" title="大致实现图："></a><strong>大致实现图：</strong></h5><p><img src="https://s2.loli.net/2022/04/14/GDIdVU5R8litqKL.png" alt="image-20220405141154377"></p>
<h5 id="交换机与队列关："><a href="#交换机与队列关：" class="headerlink" title="交换机与队列关："></a><strong>交换机与队列关：</strong></h5><p><strong>交换机</strong></p>
<p><img src="https://s2.loli.net/2022/04/14/4YsXKpdCnWR3gLy.png" alt="image-20220405141620556"></p>
<p><strong>队列</strong></p>
<p><img src="https://s2.loli.net/2022/04/14/omujXgWNTdsSEVh.png" alt="image-20220405141844488"></p>
<h4 id="生产者：-8"><a href="#生产者：-8" class="headerlink" title="生产者："></a>生产者：</h4><p>我们需要在生产者中声明一个交换机： channel.exchangeDeclare(EXCHANGE_NAME,”fanout”);   注意：谁先启动就写谁那（也可以两边都声明交换机）</p>
<p>队列也不在我们生产者中声明了，交给消费者声明，因为生产者中只需要队列的Routing key即可</p>
<p> channel.basicPublish(EXCHANGE_NAME, “queue”, null,message.getBytes());</p>
<pre class="language-none"><code class="language-none">/**
 * 生产者:
 * 我们现在使用交换机，bindingKey进行绑定发送消息，所以我们不需要声明队列，
 * 队列交给消费者声明，消费者再对队列进行设置bindingKey，并与交换机绑定bindingKey
 * 我们只需要再生产者处声明交换机即可，消费者不以不声明交换机，直接使用交换机名称即可
 */
public class EmitLog {

    public static final String EXCHANGE_NAME = "logs";

    public static void main(String[] args) throws IOException, TimeoutException {

        Channel channel = RabbitMQUtil.getChannel();

        /**
         * 声明交换机
         * 参数1，交换机名称
         * 参数2，交换机类型（Fanout（扇出类型），发布订阅类型）
         */
        channel.exchangeDeclare(EXCHANGE_NAME,"fanout");

        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            String message = scanner.next();
            //使用信道发送消息
            //参数：
            // 1、 发送到哪个交换机，我们没有创建交换机，填写空就行
            // 2、路由的RontingKey值是哪个,（告诉交换机，消息要发送到指定Routingkey的队列中）
            // 3、其他参数消息
            // 4、发送的消息体
            channel.basicPublish(EXCHANGE_NAME, "queue", null,message.getBytes());
            System.out.println(message+" ---&gt; 成功发送");
        }

    }

}</code></pre>





<h4 id="消费者：-4"><a href="#消费者：-4" class="headerlink" title="消费者："></a>消费者：</h4><p>（注意，需要两个生产者，我们只需要在创建一个生产者，并且将ReceiveLogs01改为其他提示即可如：ReceiveLogs02，<strong>Routingkey不可更改，要不然生产者发送的信息交换机就不能将消息都发送到了两个消费者了</strong>，因为生产者中发布消息给交换机需要指定一个Routingkey，如果两个消费者Routingkey不同，交换机只会给指定的那一个Routingkey的队列发送消息）</p>
<p>我们需要声明队列：  String queue = channel.queueDeclare().getQueue();  这是个临时队列，当消费者断开和该队列的连接时 队列自动删除</p>
<p>并为队列绑定交换机，并设置Routingkey并与交换机绑定： channel.queueBind(queue,EXCHANGE_NAME,”queue”);</p>
<pre class="language-none"><code class="language-none">/**
 * 消费者1，我们的bindingKey要与其他消费者相同这样就能够消费者都接收到相同的消息
 * （生产者发送消息给交换机，交换机根据bindingKey发送给队列，因为bindingKey都一样所以就可以发送）
 */
public class ReceiveLogs01 {

    public static final String EXCHANGE_NAME = "logs";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMQUtil.getChannel();

        /**
         * 声明交换机（交给生产者声明就行）
         * 参数1，交换机名称
         * 参数2，交换机类型（Fanout（扇出类型），发布订阅类型）
         * BuiltinExchangeType.FANOUT == "fanout"
         */
        //channel.exchangeDeclare(EXCHANGE_NAME,BuiltinExchangeType.FANOUT);

        /**
         * 声明一个临时队列（并获取临时队列名称）
         *  生成一个临时的队列 队列的名称是随机的
         *  当消费者断开和该队列的连接时 队列自动删除
         */
        String queue = channel.queueDeclare().getQueue();

        /**
         * 队列绑定
         * 参数1：队列名称
         * 参数2：交换名称
         * 参数3：队列bindingKey（也是设置队列bindingKey）；交换机根据queue发送消息，可发送给多个消费者
         *      生产者发送消息给交换机，交换机根据bindingKey发送给队列，因为bindingKey都一样所以就可以发送
         */
        channel.queueBind(queue,EXCHANGE_NAME,"queue");




        //成功获取生产者信息回调方法
        DeliverCallback deliverCallback = new DeliverCallback() {
            public void handle(String s, Delivery delivery) throws IOException {
                System.out.println("ReceiveLogs01 消费消息："+new String(delivery.getBody()));

            }
        };


        // 消费者取消消费的回调方法
        CancelCallback cancelCallback = new CancelCallback() {
            public void handle(String s) throws IOException {
                System.out.println(s + ":ReceiveLogs01 消费者取消消费 回调函数  逻辑代码....");
            }
        };


        System.out.println("ReceiveLogs01:等待消费中.................");
        /**
         *  消费者消费（获取对列消息）
         *   参数:
         *   1,消费哪个队列
         *   2,消费成功后是否自动应答  true：自动应答  false：手动应答
         *        应答作用：消费者发送一个消息应答，告诉RabbitMQ这个消息已经接收并且处理完毕了。RabbitMQ就可以删除它了。
         *   3,消费者成功消费的回调方法
         *   4，消费者取消消费的回调方法
         */
        channel.basicConsume(queue,true,deliverCallback,cancelCallback);
    }

}</code></pre>





<h4 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a>结果：</h4><p>可以看到，消费者1和消费者2都消费到了相同的信息</p>
<p><img src="https://s2.loli.net/2022/04/14/capLE1zoGQBnwji.png" alt="image-20220405142844948"></p>
<h3 id="直接交换机（direct）："><a href="#直接交换机（direct）：" class="headerlink" title="直接交换机（direct）："></a>直接交换机（direct）：</h3><h4 id="介绍：-1"><a href="#介绍：-1" class="headerlink" title="介绍："></a>介绍：</h4><p>我们希望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去</p>
<p><img src="https://s2.loli.net/2022/04/14/1JbkAOXp8GgPK3a.png" alt="image-20220405145232744"></p>
<p>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列 Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.</p>
<p>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p>
<h4 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a>多重绑定</h4><p><img src="https://s2.loli.net/2022/04/14/miUPfgowZ4hxy5a.png" alt="image-20220405145459224"></p>
<p>当然如果 exchange 的绑定类型是 direct，但是它绑定的多个队列的 key 如果都相同，在这种情 况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>直接交换机可以发送给不同的routingkey的队列，只需要改变发布时交换机要发送到达RoutingKey即可，</p>
<p><img src="https://s2.loli.net/2022/04/14/xV3PYC6qyIWDn4l.png" alt="image-20220405145531537"></p>
<p><img src="https://s2.loli.net/2022/04/14/xiFW2CnH6hpwe9B.png" alt="image-20220405145636633"></p>
<h4 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1:"></a>消费者1:</h4><pre class="language-none"><code class="language-none">public class ReceiveLogsDirect01 {
 private static final String EXCHANGE_NAME = "direct_logs";
 public static void main(String[] argv) throws Exception {
 	Channel channel = RabbitUtils.getChannel();
 	channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
 	String queueName = "disk";
 	
 	channel.queueDeclare(queueName, false, false, false, null);
 	channel.queueBind(queueName, EXCHANGE_NAME, "error");
 	
 	System.out.println("等待接收消息.....");
 	
 	DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; {
 		String message = new String(delivery.getBody(), "UTF-8");
 		message="接收绑定键:"+delivery.getEnvelope().getRoutingKey()+",消息:"+message;
 		File file = new File("C:\\work\\rabbitmq_info.txt");
 		FileUtils.writeStringToFile(file,message,"UTF-8");
 		System.out.println("错误日志已经接收");
 	};
 	//消费者消费（获取对列消息）
    //参数:
    //1,消费哪个对象
    //2,消费成功后是否自动应答  true：自动应答  false：手动应答
    //     应答作用：消费者发送一个消息应答，告诉RabbitMQ这个消息已经接收并且处理完毕了。RabbitMQ就可以删除它了。
    //3,消费者成功消费的回调方法
    //4，消费者取消消费的回调方法
 	channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; {
 	});
 }
}
</code></pre>



<h4 id="消费者2："><a href="#消费者2：" class="headerlink" title="消费者2："></a>消费者2：</h4><pre class="language-none"><code class="language-none">public class ReceiveLogsDirect02 {
 private static final String EXCHANGE_NAME = "direct_logs";
 public static void main(String[] argv) throws Exception {
 
     Channel channel = RabbitUtils.getChannel();
     channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
     String queueName = "console";
     
     channel.queueDeclare(queueName, false, false, false, null);
     
     channel.queueBind(queueName, EXCHANGE_NAME, "info");
     channel.queueBind(queueName, EXCHANGE_NAME, "warning");
     System.out.println("等待接收消息.....");
     
     DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; {
    	String message = new String(delivery.getBody(), "UTF-8");
     	System.out.println(" 接收绑定键 :"+delivery.getEnvelope().getRoutingKey()+", 消
  		息:"+message);
     };
     //消费者消费（获取对列消息）
     //参数:
     //1,消费哪个对象
     //2,消费成功后是否自动应答  true：自动应答  false：手动应答
     //     应答作用：消费者发送一个消息应答，告诉RabbitMQ这个消息已经接收并且处理完毕了。RabbitMQ就可以删除它了。
     //3,消费者成功消费的回调方法
     //4，消费者取消消费的回调方法
     channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; {
     });
 }
}
</code></pre>



<h4 id="生产者：-9"><a href="#生产者：-9" class="headerlink" title="生产者："></a>生产者：</h4><pre class="language-none"><code class="language-none">public class EmitLogDirect {
        private static final String EXCHANGE_NAME = "direct_logs";
        public static void main(String[] argv) throws Exception {
            try (Channel channel = RabbitUtils.getChannel()) {
                channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
                //创建多个 bindingKey
                Map&lt;String, String&gt; bindingKeyMap = new HashMap&lt;&gt;();
                bindingKeyMap.put("info","普通 info 信息");
                bindingKeyMap.put("warning","警告 warning 信息");
                bindingKeyMap.put("error","错误 error 信息");
                //debug 没有消费这接收这个消息 所有就丢失了
                bindingKeyMap.put("debug","调试 debug 信息");
                
                for (Map.Entry&lt;String, String&gt; bindingKeyEntry: bindingKeyMap.entrySet()){
                    String bindingKey = bindingKeyEntry.getKey();
                    String message = bindingKeyEntry.getValue();
                    channel.basicPublish(EXCHANGE_NAME,bindingKey, null,
                            message.getBytes("UTF-8"));
                    System.out.println("生产者发出消息:" + message);
                }
            }
        }
    }</code></pre>









<h3 id="主题类型（Topics）"><a href="#主题类型（Topics）" class="headerlink" title="主题类型（Topics）"></a>主题类型（Topics）</h3><p>使用这个类型，我们可以做到Routingkey动态化</p>
<h4 id="Topic-的要求"><a href="#Topic-的要求" class="headerlink" title="Topic 的要求"></a>Topic 的要求</h4><p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，<strong>它必须是一个单 词列表，以点号分隔开</strong>。这些单词可以是任意单词，比如说：”stock.usd.nyse”, “nyse.vmw”,  “quick.orange.rabbit”.这种类型的。当然这个单词列表最多不能超过 255 个字节。（使用这种方法就可以做到Routingkey的动态绑定）</p>
<p><strong>在这个规则列表中，其中有两个替换符是大家需要注意的</strong></p>
<p>*** ** (星号)可以代替一个单词</p>
<p><strong>#</strong>  (井号)可以替代零个或多个单词</p>
<h4 id="Topic-匹配案例"><a href="#Topic-匹配案例" class="headerlink" title="Topic 匹配案例"></a>Topic 匹配案例</h4><p><strong>下图绑定关系如下</strong></p>
<p>Q2是多绑定</p>
<p><img src="https://s2.loli.net/2022/04/14/jnmtpCIc3SvrLib.png" alt="image-20220405222728111"></p>
<p><strong>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的</strong></p>
<p>quick.orange.rabbit             被队列 Q1Q2 接收到</p>
<p>lazy.orange.elephant          被队列 Q1Q2 接收到</p>
<p>quick.orange.fox                 被队列 Q1 接收到</p>
<p>lazy.brown.fox                     被队列 Q2 接收到</p>
<p>lazy.pink.rabbit                    虽然满足两个绑定但只被队列 Q2 接收一次（因为匹配到的都是Q2）</p>
<p>quick.brown.fox                  不匹配任何绑定不会被任何队列接收到会被丢弃</p>
<p>quick.orange.male.rabbit         是四个单词不匹配任何绑定会被丢弃</p>
<p>lazy.orange.male.rabbit         是四个单词但匹配 Q2</p>
<p><strong>当队列绑定关系是下列这种情况时需要引起注意</strong></p>
<p>当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了</p>
<p>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</p>
<h4 id="生产者：-10"><a href="#生产者：-10" class="headerlink" title="生产者："></a>生产者：</h4><p>RoutingKey需要规范，看上面的<strong>Topic 的要求</strong></p>
<pre class="language-none"><code class="language-none">/**
 * 生产者
 */
public class EmitLogTopic {

    public static final String EXCHANGE_NAME = "topic_logs";

    public static void main(String[] args) throws IOException, TimeoutException {

        Channel channel = RabbitMQUtil.getChannel();


        /**
         * 声明交换机
         * 参数：
         * 1，交换机名称
         * 2，交换机类型
         */
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);



        //这是要发送消息的RoutingKey与消息主体
        Map&lt;String, String&gt; bindingKeyMap = new HashMap();
        bindingKeyMap.put("quick.orange.rabbit","被队列 Q1Q2 接收到");
        bindingKeyMap.put("lazy.orange.elephant","被队列 Q1Q2 接收到");
        bindingKeyMap.put("quick.orange.fox","被队列 Q1 接收到");
        bindingKeyMap.put("lazy.brown.fox","被队列 Q2 接收到");
        bindingKeyMap.put("lazy.pink.rabbit","虽然满足两个绑定但只被队列 Q2 接收一次");
        bindingKeyMap.put("quick.brown.fox","不匹配任何绑定不会被任何队列接收到会被丢弃");
        bindingKeyMap.put("quick.orange.male.rabbit","是四个单词不匹配任何绑定会被丢弃");
        bindingKeyMap.put("lazy.orange.male.rabbit","是四个单词但匹配 Q2");

        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = bindingKeyMap.entrySet();
        for (Map.Entry&lt;String, String&gt; entry : entries) {
            String RoutingKey = entry.getKey();
            String message = entry.getValue();

            channel.basicPublish(EXCHANGE_NAME,RoutingKey,null,message.getBytes());
            System.out.println(message+" ---&gt; 发送成功");
        }


    }

}</code></pre>





<h4 id="消费者1："><a href="#消费者1：" class="headerlink" title="消费者1："></a>消费者1：</h4><p>RoutingKey需要规范，看上面的<strong>Topic 的要求</strong></p>
<p>delivery.getEnvelope().getRoutingKey() 可获取到当前消息发送使用的RoutingKey</p>
<pre class="language-none"><code class="language-none">/**
 * 消费者1
 */
public class ReceiveLogsTopic01 {

    public static final String EXCHANGE_NAME = "topic_logs";

    public static void main(String[] args) throws IOException, TimeoutException {

        Channel channel = RabbitMQUtil.getChannel();

        /**
         * 声明交换机
         * 参数：
         * 1，交换机名称
         * 2，交换机类型
         */
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);

        String queueName="Q1";
        //使用信道调取一个队列的声明（生成队列），我们可以先不创建交换机，默认就会有一个交换机
        //参数：
        // 1、队列的名称
        // 2,队列里的消息是否需要持久化（存储磁盘），默认存储内存中
        // 3,是否需要排它 ， 该队列是否只提供给一个消费者进行消费 是否进行共享 ，true:只能一个消费者消费 false:可以多个消费者消费
        // 4、是否自动删除 ， 最后一个消费者断开连接后，该队列是否自动删除
        // 5、队列参数
        channel.queueDeclare(queueName,false,false,false,null);

        channel.queueBind(queueName,EXCHANGE_NAME,"*.orange.*");

        System.out.println("ReceiveLogsTopic01 准备消费...............");

        //成功获取生产者信息回调方法
        DeliverCallback deliverCallback = new DeliverCallback() {
            public void handle(String s, Delivery delivery) throws IOException {
                //获取RoutingKey
                System.out.println("当前队列RoutingKey ： "+delivery.getEnvelope().getRoutingKey());
                System.out.println("ReceiveLogsTopic01 消费消息："+new String(delivery.getBody()));

            }
        };


        // 消费者取消消费的回调方法
        CancelCallback cancelCallback = new CancelCallback() {
            public void handle(String s) throws IOException {
                System.out.println(s + ":ReceiveLogsTopic01 消费者取消消费 回调函数  逻辑代码....");
            }
        };

        /**
         *  消费者消费（获取对列消息）
         *   参数:
         *   1,消费哪个队列
         *   2,消费成功后是否自动应答  true：自动应答  false：手动应答
         *        应答作用：消费者发送一个消息应答，告诉RabbitMQ这个消息已经接收并且处理完毕了。RabbitMQ就可以删除它了。
         *   3,消费者成功消费的回调方法
         *   4，消费者取消消费的回调方法
         */
        channel.basicConsume(queueName,true,deliverCallback,cancelCallback);

    }

}</code></pre>





<h4 id="消费者2：-1"><a href="#消费者2：-1" class="headerlink" title="消费者2："></a>消费者2：</h4><p>RoutingKey需要规范，看上面的<strong>Topic 的要求</strong></p>
<p>delivery.getEnvelope().getRoutingKey() 可获取到当前消息发送使用的RoutingKey</p>
<pre class="language-none"><code class="language-none">/**
 * 消费者2
 */
public class ReceiveLogsTopic02 {

    public static final String EXCHANGE_NAME = "topic_logs";

    public static void main(String[] args) throws IOException, TimeoutException {

        Channel channel = RabbitMQUtil.getChannel();

        /**
         * 声明交换机
         * 参数：
         * 1，交换机名称
         * 2，交换机类型
         */
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);

        String queueName="Q2";
        //使用信道调取一个队列的声明（生成队列），我们可以先不创建交换机，默认就会有一个交换机
        //参数：
        // 1、队列的名称
        // 2,队列里的消息是否需要持久化（存储磁盘），默认存储内存中
        // 3,是否需要排它 ， 该队列是否只提供给一个消费者进行消费 是否进行共享 ，true:只能一个消费者消费 false:可以多个消费者消费
        // 4、是否自动删除 ， 最后一个消费者断开连接后，该队列是否自动删除
        // 5、队列参数
        channel.queueDeclare(queueName,false,false,false,null);

        channel.queueBind(queueName,EXCHANGE_NAME,"*.*.rabbit");
        channel.queueBind(queueName,EXCHANGE_NAME,"lazy.#");

        System.out.println("ReceiveLogsTopic02 准备消费...............");

        //成功获取生产者信息回调方法
        DeliverCallback deliverCallback = new DeliverCallback() {
            public void handle(String s, Delivery delivery) throws IOException {
                //获取RoutingKey
                System.out.println("当前队列RoutingKey ： "+delivery.getEnvelope().getRoutingKey());
                System.out.println("ReceiveLogsTopic02 消费消息："+new String(delivery.getBody()));

            }
        };


        // 消费者取消消费的回调方法
        CancelCallback cancelCallback = new CancelCallback() {
            public void handle(String s) throws IOException {
                System.out.println(s + ":ReceiveLogsTopic02 消费者取消消费 回调函数  逻辑代码....");
            }
        };

        /**
         *  消费者消费（获取对列消息）
         *   参数:
         *   1,消费哪个队列
         *   2,消费成功后是否自动应答  true：自动应答  false：手动应答
         *        应答作用：消费者发送一个消息应答，告诉RabbitMQ这个消息已经接收并且处理完毕了。RabbitMQ就可以删除它了。
         *   3,消费者成功消费的回调方法
         *   4，消费者取消消费的回调方法
         */
        channel.basicConsume(queueName,true,deliverCallback,cancelCallback);

    }

}</code></pre>





<h4 id="结果：-2"><a href="#结果：-2" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2022/04/14/RiYxFdltvyBXOmH.png" alt="image-20220406140846561"></p>
<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。 </p>
<p>应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息 消费发生异常时，将消息投入死信队列中.还有比如说: 用户在商城下单成功并点击去支付后在指定时 间未支付时自动失效</p>
<h3 id="死信的来源："><a href="#死信的来源：" class="headerlink" title="死信的来源："></a>死信的来源：</h3><p>消息 TTL 过期 （存活时间过期，消息也是有存活时间的）</p>
<p>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</p>
<p>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.</p>
<h3 id="死信队列示例："><a href="#死信队列示例：" class="headerlink" title="死信队列示例："></a>死信队列示例：</h3><h4 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h4><p>注意：是由普通队列发送给死信队列的，所以我们是要为普通队列设置一下参数</p>
<p><img src="https://s2.loli.net/2022/04/14/QgKhnaw9mrSp5cs.png" alt="image-20220406140004952"></p>
<h4 id="生产者：-11"><a href="#生产者：-11" class="headerlink" title="生产者："></a>生产者：</h4><p>我们需要为发布的消息进行参数设置：</p>
<p>AMQP.BasicProperties properties = new AMQP.BasicProperties() .builder().expiration(“10000”).build();<br>这是个链式操作，builder开始  ，build结束，中间则是设置参数的，</p>
<p>expiration是设置消息过期时间</p>
<p>生产者其实只需要将消息发送到正常普通的交换机即可，当出现死信时有普通队列将信息发送给死信交换机，然后再放入死信队列</p>
<pre class="language-none"><code class="language-none">/**
 * 生产者
 */
public class Producer {


    //普通交换机名称
    public static final String NORMAL_EXCHANGE="normal_exchange";

    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMQUtil.getChannel();
        channel.exchangeDeclare(NORMAL_EXCHANGE,"direct");

        /**
         * 设置参数（链式）
         * builder 开始
         * 设置参数  expiration设置消息有效时长  ms
         * build  结束
         */
        AMQP.BasicProperties properties = new AMQP.BasicProperties()
                .builder().expiration("10000").build();


        for (int i = 0; i &lt; 10; i++) {
            String message = "消息"+i;
            channel.basicPublish(NORMAL_EXCHANGE,"normal",properties,message.getBytes());
        }
        System.out.println("发送完成");

    }

}</code></pre>



<h4 id="普通队列消费者："><a href="#普通队列消费者：" class="headerlink" title="普通队列消费者："></a>普通队列消费者：</h4><p>我们需要需要什么两个个交换机：</p>
<p>普通交换机：我们需要进行正常信息的消费</p>
<p>死信交换机：在这声明死信交换机与队列是应为我们刚好需要使用，如果在使用时我们死信交换机或死信队列不在的话会报错</p>
<p>使用到了的队列的参数设置：</p>
<p>我们需要声明一个 Map&lt;String, Object&gt; parameter = new HashMap();</p>
<p>key为我们的参数名，固定的不会变</p>
<p>value为设置的参数</p>
<p>参数名：</p>
<p>x-dead-letter-exchange   设置死信交换机</p>
<p>x-dead-letter-routing-key  设置死信对齐</p>
<p>x-message-tt1   设置消息过期时间 ms（这个我们在生产者中设置更好）</p>
<p>x-max-length   设置队列消息个数数（当超过队列长度的消息会进入死信队列）</p>
<p>死信交换机与死信队列其实不用过多的设置，就普通的即可，我们只是将死信放入一个普通的队列而已，由于这个队列是存放死信的所以才叫私信队列，交换机也是同理，所以不用过多设置</p>
<pre class="language-none"><code class="language-none">/**
 * 消费者1，（ C1）
 */
public class NormalConsumer01 {

    //普通交换机名称
    public static final String NORMAL_EXCHANGE="normal_exchange";
    //死信交换机名称
    public static final String DEAD_EXCHANGE="dead_exchange";
    //普通队列名称
    public static final String NORMAL_QUEUE="normal_queue";
    //死信队列名称
    public static final String DEAD_QUEUE="dead_queue";

    public static void main(String[] args) throws IOException, TimeoutException {

        Channel channel = RabbitMQUtil.getChannel();


        /**
         * 声明死信交换机，死信交换机机也是普通交换机
         */
        channel.exchangeDeclare(DEAD_EXCHANGE,"direct");
        /**
         * 声明死信队列，死信队列我们不需要设置声明参数
         */
        channel.queueDeclare(DEAD_QUEUE,false,false,false,null);
        //让死信队列与死信交换机绑定
        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,"dead");

        //---------------------------------------------------------------------------

        /**
         * 声明普通交换机
         */
        channel.exchangeDeclare(NORMAL_EXCHANGE,"direct");

        /**
         * 设置参数 参数key都是固定的
         * x-dead-letter-exchange   设置死信交换机
         * x-dead-letter-routing-key  设置死信对齐
         * x-message-tt1   设置过期时间 ms
         */
        Map&lt;String, Object&gt; parameter = new HashMap();
        //告诉普通队列，死信交换机是哪个
        parameter.put("x-dead-letter-exchange",DEAD_EXCHANGE);
        //告诉普通队列，死信交队列的RoutingKey
        parameter.put("x-dead-letter-routing-key","dead");
        //设置消息过期时间，这个在生产者也可以设置，并且在生产者中设置也更好
        //parameter.put("x-message-tt1",10000);
        //设置队列长度（当超过队列长度的消息会进入死信队列）
        //parameter.put("x-max-length",6);

        /**
         * 声明普通队列，由于普通队列需要向向死信队列发送死信，所以我们需要参数
         */
        channel.queueDeclare(NORMAL_QUEUE,false,false,false,parameter);
        //普通队列与普通交换机绑定
        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,"normal");


        System.out.println("C1 准备消费......");


        //成功获取生产者信息回调方法
        DeliverCallback deliverCallback = new DeliverCallback() {
            public void handle(String s, Delivery delivery) throws IOException {
                System.out.println("c1 消费消息："+new String(delivery.getBody()));

            }
        };


        // 消费者取消消费的回调方法
        CancelCallback cancelCallback = new CancelCallback() {
            public void handle(String s) throws IOException {
                System.out.println(s + ":c1 消费者取消消费 回调函数  逻辑代码....");
            }
        };

        /**
         *  消费者消费（获取对列消息）
         *   参数:
         *   1,消费哪个队列
         *   2,消费成功后是否自动应答  true：自动应答  false：手动应答
         *        应答作用：消费者发送一个消息应答，告诉RabbitMQ这个消息已经接收并且处理完毕了。RabbitMQ就可以删除它了。
         *   3,消费者成功消费的回调方法
         *   4，消费者取消消费的回调方法
         */
        channel.basicConsume(NORMAL_QUEUE,true,deliverCallback,cancelCallback);


    }

}</code></pre>





<h4 id="死信队列消费者："><a href="#死信队列消费者：" class="headerlink" title="死信队列消费者："></a>死信队列消费者：</h4><p>由于在普通消费者中交换机与队列都已声明过，所以我们只需要使用队列名获取消息即可</p>
<pre class="language-none"><code class="language-none">/**
 * C2 死信消费者
 */
public class DeadConsumer02 {

    //死信队列名称
    public static final String DEAD_QUEUE="dead_queue";


    public static void main(String[] args) throws IOException, TimeoutException {
        Channel channel = RabbitMQUtil.getChannel();




        System.out.println("死信C2 准备消费......");


        //成功获取生产者信息回调方法
        DeliverCallback deliverCallback = new DeliverCallback() {
            public void handle(String s, Delivery delivery) throws IOException {
                System.out.println("死信c2 消费消息："+new String(delivery.getBody()));

            }
        };


        // 消费者取消消费的回调方法
        CancelCallback cancelCallback = new CancelCallback() {
            public void handle(String s) throws IOException {
                System.out.println(s + ":死信c2 消费者取消消费 回调函数  逻辑代码....");
            }
        };

        /**
         *  消费者消费（获取对列消息）
         *   参数:
         *   1,消费哪个队列
         *   2,消费成功后是否自动应答  true：自动应答  false：手动应答
         *        应答作用：消费者发送一个消息应答，告诉RabbitMQ这个消息已经接收并且处理完毕了。RabbitMQ就可以删除它了。
         *   3,消费者成功消费的回调方法
         *   4，消费者取消消费的回调方法
         */
        channel.basicConsume(DEAD_QUEUE,true,deliverCallback,cancelCallback);

    }

}</code></pre>







<h4 id="结果一（非死信）："><a href="#结果一（非死信）：" class="headerlink" title="结果一（非死信）："></a>结果一（非死信）：</h4><p><strong>没有死信产生</strong></p>
<p>普通消费者成功消费</p>
<p><img src="https://s2.loli.net/2022/04/14/owXC2GZ1tAv4qP7.png" alt="image-20220406214300928"></p>
<h4 id="结果2（死信）："><a href="#结果2（死信）：" class="headerlink" title="结果2（死信）："></a>结果2（死信）：</h4><p><strong>消费者1创建了交换机和队列后关闭了，消息过期后发送到死信队列</strong></p>
<p><strong>成功发布消息</strong></p>
<p><img src="https://s2.loli.net/2022/04/14/TMN1x3XUBFzWmpq.png" alt="image-20220406215039743"></p>
<p><strong>消息过期成为死信</strong>：</p>
<p><img src="https://s2.loli.net/2022/04/14/TzDGU4tJgrVhxdc.png" alt="image-20220406215108957"></p>
<p><strong>被死信队列消费</strong>：</p>
<p><img src="https://s2.loli.net/2022/04/14/lRjX6DM4VfWLI5b.png" alt="image-20220406215304717"></p>
<p><strong>这是超出普通队列长度后的结果：</strong></p>
<p>发送了10条消息，普通队列长度为6，<strong>注意：要设置队列的参数</strong></p>
<p><img src="https://s2.loli.net/2022/04/14/9m7u1CteIa28YE3.png" alt="image-20220406222848617"></p>
<h4 id="普通队列消费者（消息据收）："><a href="#普通队列消费者（消息据收）：" class="headerlink" title="普通队列消费者（消息据收）："></a>普通队列消费者（消息据收）：</h4><p>死信来源：消费者拒收消息</p>
<p>前面的普通队列消费者是消息存活超时与长度（长度的参数注释了）的消费者示例</p>
<p>这个是消息拒收后加入死信队列的演示，其他消费者，生产者（取消消息超时时间）和上面相同</p>
<p>注意：要改为手动应答，否则手动拒收消息是不可用的，因为自动应答后已经将消息删除了</p>
<pre class="language-none"><code class="language-none">

/**
 * 消费者1，（ C1）
 */
public class NormalConsumer01 {

    //普通交换机名称
    public static final String NORMAL_EXCHANGE="normal_exchange";
    //死信交换机名称
    public static final String DEAD_EXCHANGE="dead_exchange";
    //普通队列名称
    public static final String NORMAL_QUEUE="normal_queue";
    //死信队列名称
    public static final String DEAD_QUEUE="dead_queue";

    public static void main(String[] args) throws IOException, TimeoutException {

        final Channel channel = RabbitMQUtil.getChannel();


        /**
         * 声明死信交换机，死信交换机机也是普通交换机
         */
        channel.exchangeDeclare(DEAD_EXCHANGE,"direct");
        /**
         * 声明死信队列，死信队列我们不需要设置声明参数
         */
        channel.queueDeclare(DEAD_QUEUE,false,false,false,null);
        //让死信队列与死信交换机绑定
        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,"dead");

        //---------------------------------------------------------------------------

        /**
         * 声明普通交换机
         */
        channel.exchangeDeclare(NORMAL_EXCHANGE,"direct");

        /**
         * 设置参数 参数key都是固定的
         * x-dead-letter-exchange   设置死信交换机
         * x-dead-letter-routing-key  设置死信对齐
         * x-message-tt1   设置过期时间 ms
         * x-max-length    设置队列长度（当超过队列长度的消息会进入死信队列）
         */
        Map&lt;String, Object&gt; parameter = new HashMap();
        //告诉普通队列，死信交换机是哪个
        parameter.put("x-dead-letter-exchange",DEAD_EXCHANGE);
        //告诉普通队列，死信交队列的RoutingKey
        parameter.put("x-dead-letter-routing-key","dead");
        //设置消息过期时间，这个在生产者也可以设置，并且在生产者中设置也更好
//        parameter.put("x-message-tt1",10000);
        //设置队列长度（当超过队列长度的消息会进入死信队列）
        //parameter.put("x-max-length",6);

        /**
         * 声明普通队列，由于普通队列需要向向死信队列发送死信，所以我们需要参数
         */
        channel.queueDeclare(NORMAL_QUEUE,false,false,false,parameter);
        //普通队列与普通交换机绑定
        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,"normal");


        System.out.println("C1 准备消费......");


        //成功获取生产者信息回调方法
        DeliverCallback deliverCallback = new DeliverCallback() {
            public void handle(String s, Delivery delivery) throws IOException {

                if ("消息5".equals(new String(delivery.getBody()))){

                    System.out.println("拒收消息："+new String(delivery.getBody()));
                    /**
                     * 拒绝接收消息
                     * 参数：
                     * 1，被拒绝消息的标签（序号）
                     * 2，是否从新放回原来的队列， false：不放回，（会被交给死信队列）  true：放回原来的队列，重新进行消费
                     */
                    channel.basicReject(delivery.getEnvelope().getDeliveryTag(),false);
                }else {
                    System.out.println("c1 消费消息：" + new String(delivery.getBody()));
                    /**
                     * 确认应答
                     * 参数：
                     * 1，确认消息标签（序号），
                     * 2，是否为批量确认
                     */
                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);
                }

            }
        };


        // 消费者取消消费的回调方法
        CancelCallback cancelCallback = new CancelCallback() {
            public void handle(String s) throws IOException {
                System.out.println(s + ":c1 消费者取消消费 回调函数  逻辑代码....");
            }
        };

        /**
         *  消费者消费（获取对列消息）
         *   参数:
         *   1,消费哪个队列
         *   2,消费成功后是否自动应答  true：自动应答  false：手动应答
         *        应答作用：消费者发送一个消息应答，告诉RabbitMQ这个消息已经接收并且处理完毕了。RabbitMQ就可以删除它了。
         *   3,消费者成功消费的回调方法
         *   4，消费者取消消费的回调方法
         */
        channel.basicConsume(NORMAL_QUEUE,false,deliverCallback,cancelCallback);


    }

}

</code></pre>



<h4 id="结果：-3"><a href="#结果：-3" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2022/04/14/8b15sS7PVYnqK9M.png" alt="image-20220406225457710"></p>
<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p>
<p>延迟队列简单点理解就和我们上面死信队列中的普通队列挂机后消息有生命时长 一直等到寿命结果进入死信队列一样，这就可以当作一个延迟队列</p>
<h3 id="延迟队列使用场景"><a href="#延迟队列使用场景" class="headerlink" title="延迟队列使用场景"></a>延迟队列使用场景</h3><p>1.订单在十分钟之内未支付则自动取消</p>
<p>2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</p>
<p>3.用户注册成功后，如果三天内没有登陆则进行短信提醒。</p>
<p>4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。 </p>
<p>5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会</p>
<p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎 使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果 数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支 付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十 分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万 级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单 的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。<strong>（总结：这些场景使用定时器，性能低，但使用延迟队列就不会）</strong></p>
<p><strong>流程图：</strong></p>
<p><img src="https://s2.loli.net/2022/04/14/ORgAmL1QFPNxjHY.png" alt="image-20220407134116255"></p>
<h3 id="RabbitMQ-中的-TTL"><a href="#RabbitMQ-中的-TTL" class="headerlink" title="RabbitMQ 中的 TTL"></a>RabbitMQ 中的 TTL</h3><p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有 消息的最大存活时间，</p>
<p>单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这 条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”。如果同时配置了队列的 TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p>
<p><strong>设置信息TTL</strong></p>
<pre class="language-none"><code class="language-none">/**
 * 设置参数（链式）
 * builder 开始
 * 设置参数  expiration设置消息有效时长  ms
 * build  结束
 */
AMQP.BasicProperties properties = new AMQP.BasicProperties()
        .builder().expiration("100000").build();
//或
//AMQP.BasicProperties properties = new AMQP.BasicProperties();
//properties.setExpiration("60000");

    String message = "消息";
    channel.basicPublish(NORMAL_EXCHANGE,"normal",properties,message.getBytes());
</code></pre>





<p><strong>设置队列TTL</strong></p>
<p>x-message-ttl</p>
<pre class="language-none"><code class="language-none">/**
      * 设置参数 参数key都是固定的
      * x-dead-letter-exchange   设置死信交换机
      * x-dead-letter-routing-key  设置死信对齐
      * x-message-tt1   设置过期时间 ms
      * x-max-length    设置队列长度（当超过队列长度的消息会进入死信队列）
      */
     Map&lt;String, Object&gt; parameter = new HashMap();
     //告诉普通队列，死信交换机是哪个
     parameter.put("x-dead-letter-exchange",DEAD_EXCHANGE);
     //告诉普通队列，死信交队列的RoutingKey
     parameter.put("x-dead-letter-routing-key","dead");
     //设置消息过期时间，这个在生产者也可以设置，并且在生产者中设置也更好
     parameter.put("x-message-tt1",10000);
     //设置队列长度（当超过队列长度的消息会进入死信队列）
     //parameter.put("x-max-length",6);

     /**
      * 声明普通队列，由于普通队列需要向向死信队列发送死信，所以我们需要参数
      */
     channel.queueDeclare(NORMAL_QUEUE,false,false,false,parameter);</code></pre>





<p><strong>两者的区别</strong></p>
<p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队 列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者 之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；另外，还需 要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以 直接投递该消息到消费者，否则该消息将会被丢弃。</p>
<h3 id="测试延迟队列环境"><a href="#测试延迟队列环境" class="headerlink" title="测试延迟队列环境"></a>测试延迟队列环境</h3><h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a><strong>SpringBoot</strong></h4><h4 id="XML"><a href="#XML" class="headerlink" title="XML:"></a><strong>XML:</strong></h4><pre class="language-none"><code class="language-none">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!--RabbitMQ 依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
        &lt;version&gt;1.2.47&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;!--swagger--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.springfox&lt;/groupId&gt;
        &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
        &lt;version&gt;2.9.2&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;io.springfox&lt;/groupId&gt;
        &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
        &lt;version&gt;2.9.2&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!--RabbitMQ 测试依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;
        &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;


&lt;/dependencies&gt;</code></pre>





<h4 id="application："><a href="#application：" class="headerlink" title="application："></a><strong>application：</strong></h4><pre class="language-none"><code class="language-none">spring:
  rabbitmq:
    port: 5672  #15672是客户端，而5672是rabbitmq服务端
    host: 124.223.79.104
    username: admin
    password: Admin123</code></pre>







<h4 id="SwaggerConfig配置类："><a href="#SwaggerConfig配置类：" class="headerlink" title="SwaggerConfig配置类："></a><strong>SwaggerConfig配置类：</strong></h4><pre class="language-none"><code class="language-none">@Configuration
@EnableSwagger2
public class SwaggerConfig {

    @Bean
    public Docket webApiConfig(){
        return new Docket(DocumentationType.SWAGGER_2)
                .groupName("webApi")
                .apiInfo(webApiInfo())
                .select()
                .build();
    }

    private ApiInfo webApiInfo(){
        return new ApiInfoBuilder()
                .title("rabbitmq 接口文档")
                .description("本文档描述了 rabbitmq 微服务接口定义")
                .version("1.0")
                .contact(new Contact("enjoy6288", "http://atguigu.com","1551388580@qq.com"))
                .build();
    }

}</code></pre>







<h3 id="演示："><a href="#演示：" class="headerlink" title="演示："></a>演示：</h3><h4 id="代码架构图"><a href="#代码架构图" class="headerlink" title="代码架构图"></a>代码架构图</h4><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：（这些都是理论上的其实并没有就叫延迟交换机的）</p>
<p><img src="https://s2.loli.net/2022/04/14/KMwUW9yFboAuVn6.png" alt="image-20220407143915339"></p>
<p>接下来，我们使用的是SpringBoot，SpringBoot中交换机与队列就不写在生产者或消费者中了，都进行分开写了生产者是生产者，消费者是消费者交换机是交换机</p>
<h4 id="声明绑定配置类："><a href="#声明绑定配置类：" class="headerlink" title="声明绑定配置类："></a>声明绑定配置类：</h4><p>SpringBoot中交换机的声明与队列的声明还要交换机与队列的绑定都在配置中完成</p>
<p>new DirectExchange(EXCHANGE_X);  用于创建交换机，Exchange前面的为交换机类型</p>
<p>QueueBuilder 用于队列的声明，以及一些参数</p>
<p>BindingBuilder 用于交换机与队列绑定与设置RoutingKey</p>
<pre class="language-none"><code class="language-none">@Configuration
/**
 * 声明绑定配置类
 * 这里的配置都会提供给RabbitMQ，我们使用RabbitTemplate工具类即可发送消息
 */
public class QueueConfig {

    //普通交换机名称
    public static final String EXCHANGE_X="X";
    //普通队列名称1（消息存活10s)
    public static final String QUEUE_QA="QA";
    //普通队列1   RoutingKey
    public static final String QUEUE_QA_ROUTING_KEY="XA";
    //普通队列名称2（消息存活30s)
    public static final String QUEUE_QB="QB";
    //普通队列2   RoutingKey
    public static final String QUEUE_QB_ROUTING_KEY="XB";

    //死信交换机（也就是延迟交换机）名称
    public static final String EXCHANGE_DEAD="Y";
    //死信队列（延迟队列）名称
    public static final String QUEUE_DEAD_QD="QD";
    //死信(延迟)队列RoutingKey
    public static final String QUEUE_DEAD_QD_ROUTING_KEY="YD";



    //************************************************普通队列与交换机**********************************************************
    /**
     * 将交换机放入IOC容器管理
     * @return 返回X（普通）交换机
     */
    @Bean
    public Exchange XExchange(){

        // 声明direct（自接）类型交换机，多个构造方法，可查看源码
        return new DirectExchange(EXCHANGE_X);
    }

    /**
     * 创建队列 消息延迟（存活）为30秒
     * @return 返回创建好的队列交给IOC容器
     */
    @Bean
    public Queue queueQA(){
        /**
         * 链式
         * 使用QueueBuilder构建类进行构建队列
         * QueueBuilder构造方法是私有的所以我们没法调用构造函数创建队列
         * 我们需要使用durable持久化为我们创建队列，
         * durable这个方法中使用了QueueBuilder的构造函数创建队列并为队列设置为持久化
         * 其后面就是要设置的参数或使用withArguments(Map&lt;String, Object&gt; arguments) 使用MAP进行填写参数
         * build 替我们构造Queue （这一步才是真正的创建了队列），之前就好比是将参数给赋值好
         */
        return QueueBuilder//队列建立者
                .durable(QUEUE_QA)//队列名称并持久化
                .ttl(10000) //队列消息存活时间
                .deadLetterExchange(EXCHANGE_DEAD) //转发的死信交换机
                .deadLetterRoutingKey(QUEUE_DEAD_QD_ROUTING_KEY)//转发的死信队列RoutingKey
                .build();//构造队列
    }

    /**
     * 创建队列 消息延迟（存活）为30秒
     * @return 返回创建好的队列交给IOC容器
     */
    @Bean
    public Queue queueQB(){
        /**
         * 链式
         * 使用QueueBuilder构建类进行构建队列
         * QueueBuilder构造方法是私有的所以我们没法调用构造函数创建队列
         * 我们需要使用durable持久化为我们创建队列，
         * durable这个方法中使用了QueueBuilder的构造函数创建队列并为队列设置为持久化
         * 其后面就是要设置的参数或使用withArguments(Map&lt;String, Object&gt; arguments) 使用MAP进行填写参数
         * build 替我们构造Queue （这一步才是真正的创建了队列），之前就好比是将参数给赋值好
         */
        return QueueBuilder//队列建立者
                .durable(QUEUE_QB)//队列名称并持久化
                .ttl(30000) //队列消息存活时间
                .deadLetterExchange(EXCHANGE_DEAD) //转发的死信交换机
                .deadLetterRoutingKey(QUEUE_DEAD_QD_ROUTING_KEY)//转发的死信队列RoutingKey
                .build();//构造队列
    }

    //***************************************死信（延迟）队列与交换机**********************************************************

    /**
     * 将交换机放入IOC容器管理
     * @return 返回DEAD死信（延迟）交换机
     */
    @Bean
    public Exchange DeadExchange(){

        // 声明direct（自接）类型交换机，多个构造方法，可查看源码
        return new DirectExchange(EXCHANGE_DEAD);
    }

    /**
     * 创建队列(延迟队列，死信队列)
     * @return 返回创建好的队列交给IOC容器
     */
    @Bean
    public Queue queueDead(){
        /**
         * 链式
         * 使用QueueBuilder构建类进行构建队列
         * QueueBuilder构造方法是私有的所以我们没法调用构造函数创建队列
         * 我们需要使用durable持久化为我们创建队列，
         * durable这个方法中使用了QueueBuilder的构造函数创建队列并为队列设置为持久化
         * 其后面就是要设置的参数或使用withArguments(Map&lt;String, Object&gt; arguments) 使用MAP进行填写参数
         * build 替我们构造Queue （这一步才是真正的创建了队列），之前就好比是将参数给赋值好
         */
        return QueueBuilder.durable(QUEUE_DEAD_QD).build();
    }

    //************************************************绑定**********************************************************

    /**
     * 进行交换机与队列绑定
     * 形参会先使用Autowired规则寻找，找不到则遵循@Qualifier注解。这里不能使用@Resource
     * @param exchange 要绑定的交换机（获取的容器中的）
     * @param queue 要绑定的队列 （获取的是容器中的）
     * @return 将绑定的类返回给IOC容器，RabbitMQ会获取
     */
    @Bean
    public Binding ExchangeXBindingQueueQA(@Qualifier("XExchange") Exchange exchange,@Qualifier("queueQA") Queue queue){
       return BindingBuilder//队列建立者
               .bind(queue)//要绑定的队列
               .to(exchange)//要绑定的交换机
               .with(QUEUE_QA_ROUTING_KEY)//绑定队列的RoutingKey
               .noargs();//构造绑定
    }

    /**
     * 进行交换机与队列绑定
     * 形参会先使用Autowired规则寻找，找不到则遵循@Qualifier注解。这里不能使用@Resource
     * @param exchange 要绑定的交换机（获取的容器中的）
     * @param queue 要绑定的队列 （获取的是容器中的）
     * @return 将绑定的类返回给IOC容器，RabbitMQ会获取
     */
    @Bean
    public Binding ExchangeXBindingQueueQB(@Qualifier("XExchange") Exchange exchange,@Qualifier("queueQB") Queue queue){
        return BindingBuilder//队列建立者
                .bind(queue)//要绑定的队列
                .to(exchange)//要绑定的交换机
                .with(QUEUE_QB_ROUTING_KEY)//绑定队列的RoutingKey
                .noargs();//构造绑定
    }


    /**
     * 进行交换机与队列绑定
     * 形参会先使用Autowired规则寻找，找不到则遵循@Qualifier注解。这里不能使用@Resource
     * @param exchange 要绑定的交换机（获取的容器中的）
     * @param queue 要绑定的队列 （获取的是容器中的）
     * @return 将绑定的类返回给IOC容器，RabbitMQ会获取
     */
    @Bean
    public Binding DeadExchangeBindingQueueDead(@Qualifier("DeadExchange") Exchange exchange,@Qualifier("queueDead") Queue queue){
        return BindingBuilder//队列建立者
                .bind(queue)//要绑定的队列
                .to(exchange)//要绑定的交换机
                .with(QUEUE_DEAD_QD_ROUTING_KEY)//绑定队列的RoutingKey
                .noargs();//构造绑定
    }

}</code></pre>





<h4 id="生产者：-12"><a href="#生产者：-12" class="headerlink" title="生产者："></a>生产者：</h4><p>我们使用访问请求发送消息</p>
<p>RabbitTemplate： RabbitTemplate类用于消息发送等等，有许多方法</p>
<pre class="language-none"><code class="language-none">@Slf4j
@Controller
@RestController
public class TtlController {

    /**
     * RabbitTemplate，使用这个进行消息的一些操作
     */
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @RequestMapping("/sendMsg/{message}")
    public void publicMessage(@PathVariable("message") String message){
        log.info("发布消息：时间{} ，发布的消息为{}",new Date().toString(),message);
        /**
         * 发送消息
         * 参数：
         * 1，交换机名称
         * 2，RoutingKey
         * 3，发送的消息
         */
        rabbitTemplate.convertAndSend(QueueConfig.EXCHANGE_X
                , QueueConfig.QUEUE_QA_ROUTING_KEY
                ,"发送消息延迟为10秒,消息为："+message);

        /**
         * 发送消息
         * 参数：
         * 1，交换机名称
         * 2，RoutingKey
         * 3，发送的消息
         */
        rabbitTemplate.convertAndSend(QueueConfig.EXCHANGE_X
                , QueueConfig.QUEUE_QB_ROUTING_KEY
                ,"发送消息延迟为30秒,消息为："+message);

    }

}</code></pre>



<h4 id="消费者：-5"><a href="#消费者：-5" class="headerlink" title="消费者："></a>消费者：</h4><p>我们像延迟队列等等需要使用监听器，当队列中有消息时进行消费</p>
<pre class="language-none"><code class="language-none">/**
 * 这是个消费者的监听
 */
@Slf4j
@Component
public class DeadLetterQueueConsumer{

    /**
     * 队列的监听
     * RabbitListener :进行RabbitMQ的监听
     *      参数：
     *      queues：要监听的队列
     *
     * 方法形参是RabbitMQ给的
     * Message  消息
     * Channel 信道，可用于手动确认等等
     */
    @RabbitListener(queues = QueueConfig.QUEUE_DEAD_QD)
    public void listener(Message message, Channel channel){

        log.info("当前时间为{}，收到死信：{}",new Date().toString(),new String(message.getBody()));
    }

}</code></pre>





<h4 id="结果：-4"><a href="#结果：-4" class="headerlink" title="结果："></a>结果：</h4><p><strong>发送消息</strong></p>
<p><img src="https://s2.loli.net/2022/04/14/Vsp8vjUEewgWImz.png" alt="image-20220407222244900"></p>
<p><strong>运行结果：</strong></p>
<p><img src="https://s2.loli.net/2022/04/14/M4YPC1aRVjzLNbd.png" alt="image-20220407222256608"></p>
<h4 id="代码优化："><a href="#代码优化：" class="headerlink" title="代码优化："></a>代码优化：</h4><p>以上代码都是队列固定死了消息生命时长，如果有别的的时间那么就需要再创建一个队列，为了避免这种缺点，我们可以将消息的寿命时长设置在生产者中，发布消息时同时设置消息寿命</p>
<p><strong>一下操作都基于上面的代码</strong></p>
<p>新增一个QC队列，没有时长并于普通交换机绑定，RoutingKey为XC</p>
<p><img src="https://s2.loli.net/2022/04/14/YZrcA98opdNgUGm.png" alt="image-20220408130437393"></p>
<h5 id="不使用插件发布时延迟："><a href="#不使用插件发布时延迟：" class="headerlink" title="不使用插件发布时延迟："></a>不使用插件发布时延迟：</h5><p>​    </p>
<p>缺陷：</p>
<p>因为是使用的是基于死信队列，当消息在生产者发布时设置了超时时间，队列只会判断队列中第一个消息是否过期进入死信，如果第一个消息时间超时时间比较长而第二个消息比较短，就会导致第二个消息明明已经过期但由于队列只会查看第一个消息，导致第二个消息要等第一个消息进入死信后才会查看第二个消息（也就是消息延迟准确）</p>
<h6 id="声明绑定配置类（增加代码）："><a href="#声明绑定配置类（增加代码）：" class="headerlink" title="声明绑定配置类（增加代码）："></a>声明绑定配置类（增加代码）：</h6><pre class="language-none"><code class="language-none">//普通队列名称3（消息存活不进行设置)
public static final String QUEUE_QC="QC";
//普通队列3   RoutingKey
public static final String QUEUE_QC_ROUTING_KEY="XC";

 /**
     * 创建队列 消息延迟（存活）这个队列我们不设置消息存活时间，交给给生产者设置，这样就可以摆脱固定你性了
     * @return 返回创建好的队列交给IOC容器
     */
    @Bean
    public Queue queueQC(){
        /**
         * 链式
         * 使用QueueBuilder构建类进行构建队列
         * QueueBuilder构造方法是私有的所以我们没法调用构造函数创建队列
         * 我们需要使用durable持久化为我们创建队列，
         * durable这个方法中使用了QueueBuilder的构造函数创建队列并为队列设置为持久化
         * 其后面就是要设置的参数或使用withArguments(Map&lt;String, Object&gt; arguments) 使用MAP进行填写参数
         * build 替我们构造Queue （这一步才是真正的创建了队列），之前就好比是将参数给赋值好
         */
        return QueueBuilder//队列建立者
                .durable(QUEUE_QC) //队列名称与持久化
                .deadLetterExchange(EXCHANGE_DEAD) //绑定的死信交换机
                .deadLetterRoutingKey(QUEUE_DEAD_QD_ROUTING_KEY) //死信队列绑定的RoutingKey
                .build();//构造队列
    }
    
    
    /**
     * 进行交换机与队列绑定
     * 形参会先使用Autowired规则寻找，找不到则遵循@Qualifier注解。这里不能使用@Resource
     * @param exchange 要绑定的交换机（获取的容器中的）
     * @param queue 要绑定的队列 （获取的是容器中的）
     * @return 将绑定的类返回给IOC容器，RabbitMQ会获取
     */
    @Bean
    public Binding ExchangeXBindingQueueQC(@Qualifier("XExchange") Exchange exchange,@Qualifier("queueQC") Queue queue){
        return BindingBuilder//队列建立者
                .bind(queue)//要绑定的队列
                .to(exchange)//要绑定的交换机
                .with(QUEUE_QC_ROUTING_KEY)//绑定队列的RoutingKey
                .noargs();//构造绑定
    }
</code></pre>



<h6 id="生产者-Controller）："><a href="#生产者-Controller）：" class="headerlink" title="生产者(Controller）："></a>生产者(Controller）：</h6><p>使用MessagePostProcessor接口实现postProcessMessage()方法中设置参数</p>
<pre class="language-none"><code class="language-none">/**
 * 发送消息并为消息设置消息生命时长
 * @param message  消息
 * @param ttl 生命时长
 */
@RequestMapping("/sendMsg/{message}/{ttl}")
public void PublicMsgTtl(@PathVariable("message") String message,@PathVariable("ttl") Integer ttl){


     ttl = ttl*1000;


    /**
     * 发布消息设置的参数接口
     */
    Integer finalTtl = ttl;
    MessagePostProcessor postProcessor = new MessagePostProcessor() {
        /**
         * 设置发布消息时设置的参数
         * @param message  消息(可设置参数)
         * @return  返回message
         * @throws AmqpException
         */
        @Override
        public Message postProcessMessage(Message message) throws AmqpException {
            //getMessageProperties获取消息参数
            //setExpiration设置TTL (还有其他参数)
            message.getMessageProperties().setExpiration(finalTtl.toString());
            return message;
        }
    };
    log.info("发布消息：时间{} ，发布的消息为{},设置的延迟时长为{}秒",new Date().toString(),message,ttl);
    /**
     * 发送消息
     * 参数：
     * 1，交换机名称
     * 2，RoutingKey
     * 3，发送的消息
     */
    rabbitTemplate.convertAndSend(QueueConfig.EXCHANGE_X
            ,QueueConfig.QUEUE_QC_ROUTING_KEY
            ,"发送消息延迟"+ttl+"秒,消息为："+message
            ,postProcessor);

}</code></pre>





<h6 id="结果：-5"><a href="#结果：-5" class="headerlink" title="结果："></a>结果：</h6><p>这种方式会有问题：</p>
<p><strong>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消 息可能并不会按时“死亡“，因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</strong></p>
<p>如图输出结果：</p>
<p><img src="https://s2.loli.net/2022/04/14/gFvtsM1BHyrLNpu.png" alt="image-20220408130935566"></p>
<h5 id="使用插件发布时延迟："><a href="#使用插件发布时延迟：" class="headerlink" title="使用插件发布时延迟："></a>使用插件发布时延迟：</h5><p>可以解决消息延迟不准确（不使用插件的缺点）</p>
<h6 id="我能需要先下载插件："><a href="#我能需要先下载插件：" class="headerlink" title="我能需要先下载插件："></a><strong>我能需要先下载插件：</strong></h6><p>在官网上下载 <a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></p>
<p>下载 rabbitmq_delayed_message_exchange 插件，然后解压放置到 RabbitMQ 的插件目录。</p>
<p>插件包放置位置：/usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins</p>
<p>在插件目录使用该命令使用下载的插件：rabbitmq-plugins enable rabbitmq_delayed_message_exchange</p>
<p>插件包名称示例：rabbitmq_delayed_message_exchange-3.9.0.ez</p>
<h6 id="安装："><a href="#安装：" class="headerlink" title="安装："></a><strong>安装：</strong></h6><pre class="language-none"><code class="language-none">[root@VM-4-12-centos plugins]# rabbitmq-plugins enable rabbitmq_delayed_message_exchange
Enabling plugins on node rabbit@VM-4-12-centos:
rabbitmq_delayed_message_exchange
The following plugins have been configured:
  rabbitmq_delayed_message_exchange
  rabbitmq_management
  rabbitmq_management_agent
  rabbitmq_web_dispatch
Applying plugin configuration to rabbit@VM-4-12-centos...
The following plugins have been enabled:
  rabbitmq_delayed_message_exchange

started 1 plugins.
[root@VM-4-12-centos plugins]# service rabbitmq-server restart  #重启RabbitMQ服务
Redirecting to /bin/systemctl restart rabbitmq-server.service
[root@VM-4-12-centos plugins]# 
</code></pre>

<p><strong>命令：service rabbitmq-server restart    重启RabbitMQ服务</strong></p>
<p>x-delayed-message类型交换机是延迟交换机，消息在这个交换机中延迟，延迟时间到了后进入队列让消费者进行消费</p>
<p><img src="https://s2.loli.net/2022/04/14/hkVGx5TcnMY6I9r.png" alt="image-20220408224420080"></p>
<h6 id="使用插件后给流程图："><a href="#使用插件后给流程图：" class="headerlink" title="使用插件后给流程图："></a><strong>使用插件后给流程图：</strong></h6><p><img src="https://s2.loli.net/2022/04/14/gpo8Rz9NeGvJAIh.png" alt="image-20220409113518241"></p>
<p>使用插件后消息延迟就是在交换机中发生的了，延迟完成后再发送给队列</p>
<h6 id="声明绑定配置类"><a href="#声明绑定配置类" class="headerlink" title="声明绑定配置类"></a><strong>声明绑定配置类</strong></h6><p>我需要声明延迟交换机与队列，并且进行绑定</p>
<p>由于我们延迟交换机使用的是插件，所以我们需要自定义交换机，这样我们就可以自己指定交换机的类型，</p>
<p>延迟交换机还需要设置交换机延迟消息的类型，延迟交换机会获得到这个类型的特点，发送消息时就可以使用这个类型发送，如：fanout 类型，我们就可以广播</p>
<p>参数key：</p>
<p>x-delayed-type</p>
<pre class="language-none"><code class="language-none">/**
 * 延迟交换机配置类
 * 这里是使用我们插件的延迟队列（自己安装的）
 */
@Configuration
public class DelayedQueueConfig {

    //延迟交换机名称
    public static final String EXCHANGE_DELAYED="delayed.exchange";
    //延迟队列名称
    public static final String QUEUE_DELAYED="delayed.queue";
    //延迟队列RoutingKey
    public static final String QUEUE_DELAYED_ROUTING_KEY="delayed.routingKey";


    /**
     * 创建一个自定义交换机，交换机类型为延迟交换机（x-delayed-message）
     * @return 返回一个自定义交换机（延迟交换机）
     */
    @Bean
    public CustomExchange delayedExchange(){

        /**
         * 这是延迟交换机（x-delayed-message交换机）才有的参数
         * x-delayed-type: 延迟类型，延迟消息的类型
         *
         */
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        arguments.put("x-delayed-type","direct");

        /**
         * CustomExchange ： 创建自定义交换机，需要我们自动指定交换机类型
         * 参数：（其他交换机也有这是行参数的构造（除交换机类型外，因为这个是自定义交换机才有））
         * 1，交换机名称
         * 2，交换机类型
         * 3，交换机是否持久化
         * 4，交换机是否自动删除
         * 4，参数
         */
        return new CustomExchange(EXCHANGE_DELAYED,"x-delayed-message",true,false,arguments);
    }


    /**
     * 创建队列
     * @return 返回一个队列
     */
    @Bean
    public Queue queueDelayed(){
        //使用队列建立者创建队列，并让队列持久化，我们也可以直接new Queue（name）；创建一个队列
        return QueueBuilder.durable(QUEUE_DELAYED).build();
    }


    /**
     * 将队列于交换机进行RoutingKey绑定
     * @param customExchange 自定义交换机（延迟交换机）
     * @param queue  队列
     * @return 返回绑定结果
     */
    @Bean
    public Binding delayedExchangeBindingQueueDelayed(@Qualifier("delayedExchange") CustomExchange customExchange
            ,@Qualifier("queueDelayed") Queue queue){

        return BindingBuilder//绑定建立者
                .bind(queue)//队列
                .to(customExchange)//交换机
                .with(QUEUE_DELAYED_ROUTING_KEY)//绑定的RoutingKey
                .noargs();//构建

    }



}</code></pre>





<h6 id="生产者：-13"><a href="#生产者：-13" class="headerlink" title="生产者："></a><strong>生产者：</strong></h6><p>MessagePostProcessor 接口设置参数：</p>
<p>setDelay：设置消息延迟时间 （使用x-delayed-message类型交换机需要使用这个） ，之前没有插件使用的是setExpiration：设置消息存活时间</p>
<pre class="language-none"><code class="language-none">/**
 * 延迟交换机进行延迟（x-delayed-message类型交换机）
 */
@Slf4j
@Controller
@RestController
public class delayedController {

    @Autowired
    private RabbitTemplate rabbitTemplate;


    /**
     * 向延迟交换机发送消息
     * @param message
     * @param delayedTime
     */
    @RequestMapping("Send/DelayedMsg/{message}/{delayed}")
    public void publicDelayedMessage(@PathVariable("message") String message
            ,@PathVariable("delayed") Integer delayedTime){

        //设置参数
        MessagePostProcessor messagePostProcessor = new MessagePostProcessor() {
            @Override
            public Message postProcessMessage(Message message) throws AmqpException {
                //setDelay：设置消息延迟时间  ，之前没有插件使用的是setExpiration：设置消息存活时间
                message.getMessageProperties().setDelay(delayedTime * 1000);
                return message;
            }
        };

        log.info("发布消息：时间{} ，发布的延迟（delayed）消息为{},设置的延迟时长为{}秒",new Date().toString(),message,delayedTime);

        /**
         * 发送消息
         * 参数：
         * 1，交换机名称
         * 2，RoutingKey
         * 3，发送的消息
         */
        rabbitTemplate.convertAndSend(DelayedQueueConfig.EXCHANGE_DELAYED
                ,DelayedQueueConfig.QUEUE_DELAYED_ROUTING_KEY
                ,"发送(delayed)消息延迟"+delayedTime+"秒,消息为："+message
                ,messagePostProcessor);

    }

}</code></pre>





<h6 id="消费者：-6"><a href="#消费者：-6" class="headerlink" title="消费者："></a><strong>消费者：</strong></h6><p>@RabbitListener(queues = DelayedQueueConfig.QUEUE_DELAYED)</p>
<p>使用@RabbitListener监听，并指定监听队列</p>
<pre class="language-none"><code class="language-none">/**
 * 延迟队列监听
 */
@Slf4j
@Component
public class DelayedQueueConsumer {


    /**
     * @RabbitListener 监听
     *      queues 将的队列名称
     * @param message
     * @param channel
     */
    @RabbitListener(queues = DelayedQueueConfig.QUEUE_DELAYED)
    public void listenerDelayedQueue(Message message, Channel channel){

        log.info("当前时间为{}，收到延迟消息：{}",new Date().toString(),new String(message.getBody()));
    }

}</code></pre>





<h6 id="结果：-6"><a href="#结果：-6" class="headerlink" title="结果："></a><strong>结果：</strong></h6><p>成功解决不使用插件延迟消息的缺点，第二个消息被先消费掉了，符合预期</p>
<p><img src="https://s2.loli.net/2022/04/14/ydbkau7UMh65iJA.png" alt="image-20220409115656161"></p>
<h2 id="发布确认高级："><a href="#发布确认高级：" class="headerlink" title="发布确认高级："></a>发布确认高级：</h2><p>这里是直接配置当前项目里所以的交换机开启发布确认</p>
<p>在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？ 特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息</p>
<h3 id="发布确认-springboot-版本："><a href="#发布确认-springboot-版本：" class="headerlink" title="发布确认 springboot 版本："></a>发布确认 springboot 版本：</h3><h4 id="确认机制方案"><a href="#确认机制方案" class="headerlink" title="确认机制方案"></a>确认机制方案</h4><p><img src="https://s2.loli.net/2022/04/14/Qbm6LIcq2iT3gHB.png" alt="image-20220411192330135"></p>
<h4 id="代码架构图（交换机）"><a href="#代码架构图（交换机）" class="headerlink" title="代码架构图（交换机）:"></a>代码架构图（交换机）:</h4><p>如果交换机接挂机了，如何处理</p>
<p><img src="https://s2.loli.net/2022/04/14/3UHAoPtONKbikaV.png" alt="image-20220411192416420"></p>
<h4 id="application配置文件："><a href="#application配置文件：" class="headerlink" title="application配置文件："></a>application配置文件：</h4><p>需要在配置文件中添加spring.rabbitmq.publisher-confirm-type=correlated才能开始发布确认</p>
<p>NONE </p>
<p>​    禁用发布确认模式，是默认值 </p>
<p>CORRELATED </p>
<p>​    发布消息成功到交换器后会触发回调方法 </p>
<p> SIMPLE（是同步发布确认，单个发布确认确认效果）</p>
<p>​     经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法， 其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法 等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker</p>
<pre class="language-none"><code class="language-none">spring:
  rabbitmq:
    port: 5672  #15672是可视化客户端端口   5672  是rabbitmq服务端口
    host: 124.223.79.104
    username: admin
    password: Admin123
    #NONE禁用发布确认模式，是默认值,
    #CORRELATED发布消息成功到交换器后会触发回调方法，
    #SIMPLE经测试有两种效果
    publisher-confirm-type: correlated</code></pre>





<h4 id="声明绑定配置类：-1"><a href="#声明绑定配置类：-1" class="headerlink" title="声明绑定配置类："></a>声明绑定配置类：</h4><p>正常声明交换机与队列，并绑定</p>
<pre class="language-none"><code class="language-none">/**
 * 发布确认声明与绑定配置类
 */
@Configuration
public class ConfirmQueueConfig {


    //延迟交换机名称
    public static final String EXCHANGE_CONFIRM="confirm.exchange";
    //延迟队列名称
    public static final String QUEUE_CONFIRM="confirm.queue";
    //延迟队列RoutingKey
    public static final String QUEUE_CONFIRM_ROUTING_KEY="confirm.routingKey";


    /**
     * 声明交换机
     * @return 返回声明的交换机
     */
    @Bean
    public Exchange ConfirmExchange(){
        return new DirectExchange(EXCHANGE_CONFIRM);
    }

    /**
     * 声明队列
     * @return 返回创建的队列
     */
    @Bean
    public Queue ConfirmQueue(){
        return QueueBuilder.durable(QUEUE_CONFIRM).build();
    }

    /**
     * 绑定
     * @param exchange 交换机
     * @param queue 队列
     * @return 返回绑定结构
     */
    @Bean
    public Binding ExchangeConfirmBindingConfirmExchange(@Qualifier("ConfirmExchange") Exchange exchange
            ,@Qualifier("ConfirmQueue") Queue queue){
        return BindingBuilder.bind(queue).to(exchange).with(QUEUE_CONFIRM_ROUTING_KEY).noargs();
    }


}</code></pre>



<h4 id="生产者：-14"><a href="#生产者：-14" class="headerlink" title="生产者："></a>生产者：</h4><p>需要注意下发送消息中的CorrelationData这个参数，这个参数里的信息是要给我们交换机发布确认回调方法的，回调方法中的CorrelationData就是我们在生产者中创建的</p>
<pre class="language-none"><code class="language-none">/**
 * 发布确认生产者
 */
@Slf4j
@Controller
@RestController
public class ConfirmController {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    /**
     * 发布消息
     * @param message
     */
    @RequestMapping("confirm/Msg/{message}")
    public void publicMessage(@PathVariable("message") String message){
        //回调方法中显示的CorrelationData实例,无参构造 id为UUID
        CorrelationData correlationData = new CorrelationData();
        correlationData.setReturned(new ReturnedMessage(new Message(message.getBytes())
                ,1
                ,"replyText"
                ,ConfirmQueueConfig.EXCHANGE_CONFIRM
                ,ConfirmQueueConfig.QUEUE_CONFIRM_ROUTING_KEY
                ));

        rabbitTemplate.convertAndSend(ConfirmQueueConfig.EXCHANGE_CONFIRM  //交换机
                ,ConfirmQueueConfig.QUEUE_CONFIRM_ROUTING_KEY //RoutingKey
                ,message //发送的消息
                ,correlationData  //回调方法中CorrelationData的实例
        );
        log.info("发布确认生产者，发送消息:{}",message);
    }

}</code></pre>



<h4 id="消费者：-7"><a href="#消费者：-7" class="headerlink" title="消费者："></a>消费者：</h4><pre class="language-none"><code class="language-none">/**
 * 发布确认消费者
 */
@Slf4j
@Component
public class ConfirmQueueConsumer {


    @RabbitListener(queues = ConfirmQueueConfig.QUEUE_CONFIRM)
    public void ConfirmListenerQueue(Message message, Channel channel){
      log.info("发布确认消费者接收到队列消息，消费消息:{}",new String(message.getBody()));
    }

}</code></pre>



<h4 id="回调实现类："><a href="#回调实现类：" class="headerlink" title="回调实现类："></a>回调实现类：</h4><p><strong>生产者与交换机发布确认回调</strong></p>
<p>我们需要将我们创建的回调实现类注入给RabbitTemplate这样RabbitTemplate才能调用我们的回调方法，要不然RabbitTemplate是没有回调实现类的</p>
<p> @PostConstruct //被注解的方法，在对象加载完依赖注入后执行,对应的还有@PreDestroy，在对象消亡之前执行</p>
<p>correlationData 这个实参就是我们生产者创建发送过来的correlationData</p>
<pre class="language-none"><code class="language-none">/**
 * 生产者与交换机发布确认回调
 * 使用回调方法类接口,要使用需要开始发布确认
 */
@Slf4j
@Component
public class ConfirmCallback implements RabbitTemplate.ConfirmCallback {


    @Autowired
    private RabbitTemplate rabbitTemplate;

    /**
     * 注入实现类给RabbitTemplate调用
     * 由于RabbitTemplate.ConfirmCallback为内部接口
     * 而我们实现了他的接口但是他并不知道，所以我们需要将当前实现类给注入进去
     */
    @PostConstruct //被注解的方法，在对象加载完依赖注入后执行,对应的还有@PreDestroy，在对象消亡之前执行
    private void init(){
        rabbitTemplate.setConfirmCallback(this);
    }


    /**
     * 实现回调方法，不管成功还是失败都会调用
     * @param correlationData  保存回调消息的ID及相关信息
     *        这个对象并不是他自动生成的，而是由我们在生产者发送消息时创建发送过来的
     *        convertAndSend（）发送消息这个方法有大量的重载，里面有好几个重载方法中就要我们填充correlationData对象实例
     *        如果我们不实现发送过来，那么这边correlationData对象也会为空
     * @param b  交换机是否成功接收消息  true：成功     false：失败
     * @param s  失败原因   成功：null   失败：失败原因信息
     */
    @Override
    public void confirm(CorrelationData correlationData, boolean b, String s) {

        //获取信息，为防止信息id为null而报错
        String id = correlationData.getId()!=null?correlationData.getId():"null";

        if (b){
            log.info("交换机成功接收消息：消息ID为：{}",id);
        }else {
            log.info("交换机接收消息失败：消息ID为：{},失败原因:{}",id,s);
        }

    }
}</code></pre>



<h4 id="结果：-7"><a href="#结果：-7" class="headerlink" title="结果："></a>结果：</h4><h5 id="正常结果："><a href="#正常结果：" class="headerlink" title="正常结果："></a><strong>正常结果：</strong></h5><p><img src="https://s2.loli.net/2022/04/14/MeLHI1649s2pkhA.png" alt="image-20220411211456808"></p>
<h5 id="交换机宕机结果："><a href="#交换机宕机结果：" class="headerlink" title="交换机宕机结果："></a>交换机宕机结果：</h5><p>将生产者中发送消息的交换机故意填写错误，这样就可以演示交换机异常宕机效果了</p>
<p>结果：</p>
<p><img src="https://s2.loli.net/2022/04/14/iKfho6wMQV8s1Jj.png" alt="image-20220411211802755"></p>
<h5 id="队列宕机结果："><a href="#队列宕机结果：" class="headerlink" title="队列宕机结果："></a>队列宕机结果：</h5><p>将生产者中发送消息的队列RoutingKey故意填写成错误，这样就可以演示队列异常宕机效果了</p>
<p>结果：</p>
<p>可以看到结果是调用的是成功回调，这是因为这个只限于生产者与交换机的回调，交换机并没有成功将信息发送给指定的队列，但依旧调用成功</p>
<p>队列并没有回调，直接导致信息丢失，并且生产者还不知道，我们需要开始退回publisher-returns: true 下我们就介绍下回退 </p>
<p><img src="https://s2.loli.net/2022/04/14/NKMEcJ68H4G27PW.png" alt="image-20220411212040403"></p>
<h3 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息:"></a>回退消息:</h3><p><strong>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息</strong>，如果发现该消息不可路由(发送给消费者)，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。那么如何 让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p>
<h4 id="开启回退（mandatory-参数）："><a href="#开启回退（mandatory-参数）：" class="headerlink" title="开启回退（mandatory 参数）："></a>开启回退（mandatory 参数）：</h4><p>publisher-returns: true   //这个参数是用来开始退回的</p>
<pre class="language-none"><code class="language-none">spring:
  rabbitmq:
    port: 5672  #15672是可视化客户端端口   5672  是rabbitmq服务端口
    host: 124.223.79.104
    username: admin
    password: Admin123
    #NONE禁用发布确认模式，是默认值,
    #CORRELATED发布消息成功到交换器后会触发回调方法，
    #SIMPLE经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法
    publisher-confirm-type: correlated
    publisher-returns: true  #开启信息回退，这样当交换机路由消息给队列失败就可以退回消息</code></pre>





<h4 id="回调实现类：-1"><a href="#回调实现类：-1" class="headerlink" title="回调实现类："></a>回调实现类：</h4><p>RabbitTemplate.ReturnsCallback     退回接口，也就是交换机与队列之前的确认</p>
<p>退回即可的方法中returnedMessage 实参也同样是我们在生产者或交换机回调中创建的</p>
<p>退回实现同样也需要注入给RabbitTemplate，使它能够调用</p>
<pre class="language-none"><code class="language-none">/**
 * 发布确认回调
 * 使用回调方法类接口,要使用需要开始发布确认
 * RabbitTemplate.ConfirmCallback 交换机发布确认
 * RabbitTemplate.ReturnsCallback 交换机退回，也就是交换机与队列之前的确认
 */
@Slf4j
@Component
public class ConfirmCallback implements RabbitTemplate.ConfirmCallback,RabbitTemplate.ReturnsCallback {


    @Autowired
    private RabbitTemplate rabbitTemplate;

    /**
     * 注入实现类给RabbitTemplate调用
     * 由于RabbitTemplate.ConfirmCallback为内部接口，RabbitTemplate.ReturnsCallback同样也需要
     * 而我们实现了他的接口但是他并不知道，所以我们需要将当前实现类给注入进去
     */
    @PostConstruct //被注解的方法，在对象加载完依赖注入后执行,对应的还有@PreDestroy，在对象消亡之前执行
    private void init(){
        rabbitTemplate.setConfirmCallback(this);
        rabbitTemplate.setReturnsCallback(this);
    }


    /**
     * 实现回调方法，不管成功还是失败都会调用
     * @param correlationData  保存回调消息的ID及相关信息
     *        这个对象并不是他自动生成的，而是由我们在生产者发送消息时创建发送过来的
     *        convertAndSend（）发送消息这个方法有大量的重载，里面有好几个重载方法中就要我们填充correlationData对象实例
     *        如果我们不实现发送过来，那么这边correlationData对象也会为空
     * @param b  交换机是否成功接收消息  true：成功     false：失败
     * @param s  失败原因   成功：null   失败：失败原因信息
     */
    @Override
    public void confirm(CorrelationData correlationData, boolean b, String s) {

        //获取信息，为防止信息id为null而报错
        String id = correlationData.getId()!=null?correlationData.getId():"null";

        if (b){
            log.info("交换机成功接收消息：消息ID为：{}",id);
        }else {
            log.info("交换机接收消息失败：消息ID为：{},失败原因:{}",id,s);
        }

    }


    /**
     * 路由失败回调
     * 退回方法，交换机路由（发送消息）给队列时失败的回调
     * @param returnedMessage   消息的一些参数，同意在消费者中设置的，CorrelationData中的参数
     */
    @Override
    public void returnedMessage(ReturnedMessage returnedMessage) {
        log.info("路由失败，交换机退回消息：{},交换机是：{},RoutingKey是：{}，退回的原因：{}",
                returnedMessage.getMessage(),returnedMessage.getExchange(),returnedMessage.getRoutingKey());
    }
}</code></pre>





<h4 id="生产者：-15"><a href="#生产者：-15" class="headerlink" title="生产者："></a>生产者：</h4><p>我们将RoutingKey故意写错，这样就没有这个RoutingKey，那么就可以演示宕机了，使得交换机不能将消息路由（发送）到队列，看下是否会调用退回回调方法</p>
<pre class="language-none"><code class="language-none">/**
 * 发布确认生产者
 */
@Slf4j
@Controller
@RestController
public class ConfirmController {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    /**
     * 发布消息
     * @param message
     */
    @RequestMapping("confirm/Msg/{message}")
    public void publicMessage(@PathVariable("message") String message){
        //回调方法中显示的CorrelationData实例,无参构造 id为UUID
        CorrelationData correlationData = new CorrelationData();
        correlationData.setReturned(new ReturnedMessage(new Message(message.getBytes())
                ,1
                ,"replyText"
                ,ConfirmQueueConfig.EXCHANGE_CONFIRM
                ,ConfirmQueueConfig.QUEUE_CONFIRM_ROUTING_KEY
                ));

        rabbitTemplate.convertAndSend(ConfirmQueueConfig.EXCHANGE_CONFIRM  //交换机
                ,ConfirmQueueConfig.QUEUE_CONFIRM_ROUTING_KEY+"111" //RoutingKey
                ,message //发送的消息
                ,correlationData  //回调方法中CorrelationData的实例
        );
        log.info("发布确认生产者，发送消息:{}",message);
    }

}</code></pre>





<h4 id="消费者：-8"><a href="#消费者：-8" class="headerlink" title="消费者："></a>消费者：</h4><p>消费者其实在这没多打用，因为我们都没有发送到消费者就宕机了</p>
<pre class="language-none"><code class="language-none">/**
 * 发布确认消费者
 */
@Slf4j
@Component
public class ConfirmQueueConsumer {


    @RabbitListener(queues = ConfirmQueueConfig.QUEUE_CONFIRM)
    public void ConfirmListenerQueue(Message message, Channel channel){
      log.info("发布确认消费者接收到队列消息，消费消息:{}",new String(message.getBody()));
    }

}</code></pre>





<h4 id="结果：-8"><a href="#结果：-8" class="headerlink" title="结果："></a>结果：</h4><p>调用了退回回调方法，这样我们就不用担心消息不明不白的丢失了</p>
<p><img src="https://s2.loli.net/2022/04/14/2dNjO1WSxozQgsa.png" alt="image-20220412115323648"></p>
<h3 id="备份交换机："><a href="#备份交换机：" class="headerlink" title="备份交换机："></a>备份交换机：</h3><p>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息 无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然 后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者 所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增 加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的 复杂性，该怎么做呢？前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些 处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。什么是备份交换机呢？备份 交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时， 就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由 备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑 定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都 进入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行<strong>监测</strong>和<strong>报警</strong>。</p>
<h4 id="代码架构图："><a href="#代码架构图：" class="headerlink" title="代码架构图："></a>代码架构图：</h4><p><strong>包含发布确认高级篇代码（包含回退消息但代码不会再放出来，代码和上面相同只是多加了一些）</strong></p>
<p><img src="https://s2.loli.net/2022/04/14/wOc94qreSfyJl5E.png" alt="image-20220413171253890"></p>
<h4 id="声明绑定配置类：-2"><a href="#声明绑定配置类：-2" class="headerlink" title="声明绑定配置类："></a>声明绑定配置类：</h4><p>普通交换机使用ExchangeBuilder交换机建立者来创建交换机，使用alternate方法进行备份交换机绑定，alternate方法本质还是调用withArgument（）方法填写参数</p>
<p>备份交换机是发布订阅类型</p>
<p>其他都是常规声明绑定</p>
<pre class="language-none"><code class="language-none">
/**
 * 发布确认声明与绑定配置类
 */
@Configuration
public class ConfirmQueueConfig {

    //___________________________声明名称__________________________________________

    //确认交换机名称
    public static final String EXCHANGE_CONFIRM="confirm.exchange";
    //确认队列名称
    public static final String QUEUE_CONFIRM="confirm.queue";
    //确认队列RoutingKey
    public static final String QUEUE_CONFIRM_ROUTING_KEY="confirm.routingKey";


    //备份交换机名称
    public static final String EXCHANGE_BACKUP="backup.exchange";
    //备份队列名称
    public static final String QUEUE_BACKUP="backup.queue";
    //备份队列RoutingKey
    public static final String QUEUE_BACKUP_WARNING_ROUTING_KEY="backup.warning";
    //警告队列名称
    public static final String QUEUE_WARNING="warning.queue";


    //_______________________________声明交换机_____________________________________________-


    /**
     * 声明交换机
     * @return 返回声明的交换机
     */
    @Bean
    public Exchange ConfirmExchange(){
        /**
         * 由于我们需要绑定备份交换机，所以我们需要使用交换机建立者，填写参数
         */
        return ExchangeBuilder//交换机建立者
                .directExchange(EXCHANGE_CONFIRM)  //交换机类型与名称
                .durable(true)  //是否持久化
                .alternate(EXCHANGE_BACKUP)  //绑定备份的交换机名称，这个方法中也是调用这个方法withArgument填写参数
                .build(); //构建交换机
    }

    /**
     * 声明备份交换机，扇出类型交换机
     * @return 返回声明的交换机
     */
    @Bean
    public Exchange BackupExchange(){
        return new FanoutExchange(EXCHANGE_BACKUP);
    }


    //____________________________________声明队列____________________________________________________


    /**
     * 声明队列
     * @return 返回创建的队列
     */
    @Bean
    public Queue ConfirmQueue(){
        return QueueBuilder.durable(QUEUE_CONFIRM).build();
    }






    /**
     * 声明（备份队列）队列，备份交换机路由的队列
     * @return 返回创建的队列
     */
    @Bean
    public Queue BackupQueue(){
        return QueueBuilder.durable(QUEUE_BACKUP).build();
    }



    /**
     * 声明警告队列(warning)队列,备份交换机路由的队列
     * @return 返回创建的队列
     */
    @Bean
    public Queue WarningQueue(){
        return QueueBuilder.durable(QUEUE_WARNING).build();
    }


    //__________________________RoutingKey绑定_________________________________________




    /**
     * 绑定
     * @param exchange 交换机
     * @param queue 队列
     * @return 返回绑定结构
     */
    @Bean
    public Binding ExchangeConfirmBindingConfirmQueue(@Qualifier("ConfirmExchange") Exchange exchange
            ,@Qualifier("ConfirmQueue") Queue queue){
        return BindingBuilder.bind(queue).to(exchange).with(QUEUE_CONFIRM_ROUTING_KEY).noargs();
    }

    /**
     * 备份交换机绑定
     * @param exchange 交换机
     * @param queue 队列 备份消息队列
     * @return 返回绑定结构
     */
    @Bean
    public Binding ExchangeConfirmBackupQueue(@Qualifier("BackupExchange") Exchange exchange
            ,@Qualifier("BackupQueue") Queue queue){
        return BindingBuilder.bind(queue).to(exchange).with(QUEUE_BACKUP_WARNING_ROUTING_KEY).noargs();
    }



    /**
     * 备份交换机绑定
     * @param exchange 交换机
     * @param queue 队列 警告消息队列
     * @return 返回绑定结构
     */
    @Bean
    public Binding ExchangeConfirmBinding(@Qualifier("BackupExchange") Exchange exchange
            ,@Qualifier("WarningQueue") Queue queue){
        return BindingBuilder.bind(queue).to(exchange).with(QUEUE_BACKUP_WARNING_ROUTING_KEY).noargs();
    }


}</code></pre>





<h4 id="生产者：-16"><a href="#生产者：-16" class="headerlink" title="生产者："></a>生产者：</h4><p>我们将RoutingKey故意写错，这样就没有这个RoutingKey，那么就可以演示宕机了，使得交换机不能将消息路由（发送）到队列，看下是否会调用退回回调方法</p>
<pre class="language-none"><code class="language-none">/**
 * 发布确认生产者
 */
@Slf4j
@Controller
@RestController
public class ConfirmController {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    /**
     * 发布消息
     * @param message
     */
    @RequestMapping("confirm/Msg/{message}")
    public void publicMessage(@PathVariable("message") String message){
        //回调方法中显示的CorrelationData实例,无参构造 id为UUID
        CorrelationData correlationData = new CorrelationData();
        correlationData.setReturned(new ReturnedMessage(new Message(message.getBytes())
                ,1
                ,"replyText"
                ,ConfirmQueueConfig.EXCHANGE_CONFIRM
                ,ConfirmQueueConfig.QUEUE_CONFIRM_ROUTING_KEY
                ));

        rabbitTemplate.convertAndSend(ConfirmQueueConfig.EXCHANGE_CONFIRM  //交换机
                ,ConfirmQueueConfig.QUEUE_CONFIRM_ROUTING_KEY+"111" //RoutingKey
                ,message //发送的消息
                ,correlationData  //回调方法中CorrelationData的实例
        );
        log.info("发布确认生产者，发送消息:{}",message);
    }

}</code></pre>





<h4 id="消费者：-9"><a href="#消费者：-9" class="headerlink" title="消费者："></a>消费者：</h4><pre class="language-none"><code class="language-none">/**
 * 备份交换机备份队列消息者与警告队列消费者
 */
@Slf4j
@Component
public class BackupConsumer {

    /**
     * 监听备份队列消息
     * @param message 路由失败的一些消息
     * @param channel
     */
    @RabbitListener(queues = ConfirmQueueConfig.QUEUE_BACKUP)
    public void BackupQueueListener(Message message, Channel channel){
        log.info("备份队列备份消息：{}",new String(message.getBody()));
    }

    /**
     * 监听警告队列消息
     * @param message 路由失败的一些消息
     * @param channel
     */
    @RabbitListener(queues = ConfirmQueueConfig.QUEUE_WARNING)
    public void WarningQueueListener(Message message, Channel channel){
        log.info("警告队列：路由失败，RoutingKey为：{}",message.getMessageProperties().getReceivedRoutingKey());
    }
}</code></pre>



<h4 id="结果：-9"><a href="#结果：-9" class="headerlink" title="结果："></a>结果：</h4><p>注意：重新启动项目的时候需要把原来的 confirm.exchange 删除因为我们修改了其绑定属性，不然报以下错:</p>
<p><img src="https://s2.loli.net/2022/04/14/qoFpAWPzv9BN8y2.png" alt="image-20220413172303951"></p>
<p><strong>运行结果</strong>：</p>
<p><img src="https://s2.loli.net/2022/04/14/yeAY9igFENJBKta.png" alt="image-20220413172332796"></p>
<p>mandatory 参数（回退）与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先 级高，经过上面结果显示答案是备份交换机优先级高。</p>
<h2 id="RabbitMQ-其他知识点"><a href="#RabbitMQ-其他知识点" class="headerlink" title="RabbitMQ 其他知识点"></a>RabbitMQ 其他知识点</h2><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性:"></a>幂等性:</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念:"></a>概念:</h4><p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误 立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等,(说简单就行消息重复发送)</p>
<h4 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h4><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但 实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费 者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消 息时用该 id 先判断该消息是否已消费过。</p>
<h4 id="消费端的幂等性保障"><a href="#消费端的幂等性保障" class="headerlink" title="消费端的幂等性保障"></a>消费端的幂等性保障</h4><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。业界主流的幂等性有两种操作:a. 唯一 ID+指纹码机制,利用数据库主键去重, b.利用 redis 的原子性去实现</p>
<h4 id="唯一-ID-指纹码机制"><a href="#唯一-ID-指纹码机制" class="headerlink" title="唯一 ID+指纹码机制"></a>唯一 ID+指纹码机制</h4><p>指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基 本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存 在数据库中,优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数 据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p>
<h4 id="Redis-原子性"><a href="#Redis-原子性" class="headerlink" title="Redis 原子性"></a>Redis 原子性</h4><p>利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费</p>
<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列:"></a>优先级队列:</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h3><p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创 造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存 放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景， 所以订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。</p>
<p><img src="https://s2.loli.net/2022/04/14/s9w4TzgEviFQrB6.png" alt="image-20220413231021607"></p>
<h3 id="演示：-1"><a href="#演示：-1" class="headerlink" title="演示："></a>演示：</h3><h4 id="SpringBoot使用"><a href="#SpringBoot使用" class="headerlink" title="SpringBoot使用:"></a>SpringBoot使用:</h4><h5 id="声明配置类："><a href="#声明配置类：" class="headerlink" title="声明配置类："></a>声明配置类：</h5><p>队列参数：</p>
<p>maxPriority（int max）；开启优先级并设置队列最大优先是多少</p>
<p>其他都是正常声明</p>
<pre class="language-none"><code class="language-none">/**
 * 优先级队列声明绑定配置类
 */
@Configuration
public class PriorityQueueConfig {

    //交换机（普通）名称
    public static final String EXCHANGE_PRIORITY="priority.exchange";
    //优先级队列名称
    public static final String QUEUE_PRIORITY="priority.queue";
    //队列RoutingKey
    public static final String QUEUE_PRIORITY_ROUTING_KEY="priority.routingKey";


    @Bean
    public Exchange PriorityExchange(){
        return new DirectExchange(EXCHANGE_PRIORITY);
    }


    /**
     * 创建优先级队列
     * 其实也就是为这个队列配置优先级权限
     * maxPriority（）最大优先级是多少 0 - 255
     * @return 返回队列
     */
    @Bean
    public Queue PriorityQueue(){
        return QueueBuilder.durable(QUEUE_PRIORITY).maxPriority(10).build();
    }

    /**
     * 绑定RoutingKey
     * @param exchange
     * @param queue
     * @return
     */
    @Bean
    public Binding PriorityExchangeBindingPriorityQueue(@Qualifier("PriorityExchange") Exchange exchange
            ,@Qualifier("PriorityQueue") Queue queue){
        return BindingBuilder.bind(queue).to(exchange).with(QUEUE_PRIORITY_ROUTING_KEY).noargs();
    }
}</code></pre>





<h5 id="生产者：-17"><a href="#生产者：-17" class="headerlink" title="生产者："></a>生产者：</h5><p><strong>注意：我们第一次启动我们要先不使用消费者消费，要不然发一条消息消费者消息一条，这样就没有机会排序了，放消息发送完成后再开启消费者</strong></p>
<p>设置发送消息参数：</p>
<p>发送消息设置参数实现：MessagePostProcessor </p>
<p> /**<br>         * 设置参数<br>                  */<br>        ​        MessagePostProcessor messagePostProcessor = new MessagePostProcessor() {<br>        ​            //设置参数方法，message.getMessageProperties()获取消息参数后设置，链式操作<br>            @Override<br>            public Message postProcessMessage(Message message) throws AmqpException {<br>            ​    message.getMessageProperties().setPriority(5);<br>            ​    return message;<br>            }<br>        ​        };</p>
<pre class="language-none"><code class="language-none">/**
 * 生产者
 * 优先级队列发消息生产者
 */
@Slf4j
@Controller
@RestController
public class PriorityController {
    /**
     * RabbitTemplate，使用这个进行消息的一些操作
     */
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @RequestMapping("priority/Msg/{message}")
    private void publicMessage(@PathVariable("message")String message){

        /**
         * 设置参数
         */
        MessagePostProcessor messagePostProcessor = new MessagePostProcessor() {
        	//设置参数方法，message.getMessageProperties()获取消息参数后设置，链式操作	
            @Override
            public Message postProcessMessage(Message message) throws AmqpException {
                message.getMessageProperties().setPriority(5);
                return message;
            }
        };


        for (int i = 1; i &lt;= 100; i++) {
            String msg="消息："+message+i;
            /**
             * 发布确认回调中的消息详细详细配置
             */
            CorrelationData correlationData = new CorrelationData();
            correlationData.setReturned(new ReturnedMessage(new Message(msg.getBytes()),0,""
                    ,PriorityQueueConfig.EXCHANGE_PRIORITY,PriorityQueueConfig.QUEUE_PRIORITY_ROUTING_KEY));


            if (i==23){
                //发送第23条消息时为它设置优先级为5
                rabbitTemplate.convertAndSend(PriorityQueueConfig.EXCHANGE_PRIORITY
                        ,PriorityQueueConfig.QUEUE_PRIORITY_ROUTING_KEY
                        ,msg
                        ,messagePostProcessor
                        ,correlationData);
            }else {
                rabbitTemplate.convertAndSend(PriorityQueueConfig.EXCHANGE_PRIORITY
                        , PriorityQueueConfig.QUEUE_PRIORITY_ROUTING_KEY
                        , msg
                        , correlationData);
            }
        }
        System.out.println("消息发送成功");
    }
}</code></pre>





<h5 id="消费者：-10"><a href="#消费者：-10" class="headerlink" title="消费者："></a>消费者：</h5><p>一定要注意导的包，导错包的话是会报错的</p>
<pre class="language-none"><code class="language-none">@Slf4j
@Component
public class PriorityConsumer {

    @RabbitListener(queues = PriorityQueueConfig.QUEUE_PRIORITY)
    public void PriorityListener(Message message, Channel channel){
        log.info("优先级队列消费者消费消息:{}",new String(message.getBody()));
    }
}</code></pre>



<h5 id="结果：-10"><a href="#结果：-10" class="headerlink" title="结果："></a>结果：</h5><p><strong>第一次启动，发送消息但消费者不启动</strong></p>
<p>直接注释@RabbitListener（）就可以关闭了</p>
<p><img src="https://s2.loli.net/2022/04/14/KfZQh4kiJuLWezg.png" alt="image-20220414143225722"></p>
<p><strong>第二次启动，不发送消息，开启消费者</strong></p>
<p><img src="https://s2.loli.net/2022/04/14/asrFH5iuNLGUMSd.png" alt="image-20220414143318166"></p>
<p>可以看到，由于我们第23条信息我们设置的优先级为5，其他信息优先级为默认，在优先级队列排序下，第23条消息先被消费了</p>
<p><strong>优先级队列标识：</strong></p>
<p><img src="https://s2.loli.net/2022/04/14/CrJ24mQxncL7hlR.png" alt="image-20220414143544177"></p>
<h4 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用:"></a>普通使用:</h4><h5 id="如何添加："><a href="#如何添加：" class="headerlink" title="如何添加："></a>如何添加：</h5><p>1.控制台页面添加</p>
<p><img src="https://s2.loli.net/2022/04/14/I9BT3g6LEKb4R8y.png" alt="image-20220414143835403"></p>
<p><strong>2,队列中代码添加优先级</strong></p>
<pre class="language-none"><code class="language-none">Map&lt;String, Object&gt; params = new HashMap();
params.put("x-max-priority", 10);
channel.queueDeclare("hello", true, false, false, params);
</code></pre>

<p><img src="https://s2.loli.net/2022/04/14/kfZMNmxbQrPvo5p.png" alt="image-20220414143922270"></p>
<p><strong>3.消息中代码添加优先级</strong></p>
<pre class="language-none"><code class="language-none">AMQP.BasicProperties properties = new 
AMQP.BasicProperties().builder().priority(5).build();</code></pre>



<h5 id="演示：-2"><a href="#演示：-2" class="headerlink" title="演示："></a>演示：</h5><h6 id="生产者：-18"><a href="#生产者：-18" class="headerlink" title="生产者："></a>生产者：</h6><pre class="language-none"><code class="language-none">
public class Producer {
    private static final String QUEUE_NAME="hello";
    public static void main(String[] args) throws Exception {
        try (Channel channel = RabbitMqUtils.getChannel();) {
            //给消息赋予一个 priority 属性
            AMQP.BasicProperties properties = new
                    AMQP.BasicProperties().builder().priority(5).build();
            for (int i = 1; i &lt;11; i++) {
                String message = "info"+i;
                if(i==5){
                    channel.basicPublish("", QUEUE_NAME, properties, message.getBytes());
                }else{
                    channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
                }
                System.out.println("发送消息完成:" + message);
            }
        }
    }
}</code></pre>





<h6 id="消费者：-11"><a href="#消费者：-11" class="headerlink" title="消费者："></a>消费者：</h6><pre class="language-none"><code class="language-none">public class Consumer {
    private static final String QUEUE_NAME="hello";
    public static void main(String[] args) throws Exception {
        Channel channel = RabbitMqUtils.getChannel();
        //设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU
        Map&lt;String, Object&gt; params = new HashMap();
        params.put("x-max-priority", 10);
        channel.queueDeclare(QUEUE_NAME, true, false, false, params);
        System.out.println("消费者启动等待消费......");
        DeliverCallback deliverCallback=(consumerTag, delivery)-&gt;{
            String receivedMessage = new String(delivery.getBody());
            System.out.println("接收到消息:"+receivedMessage);
        };
        channel.basicConsume(QUEUE_NAME,true,deliverCallback,(consumerTag)-&gt;{
            System.out.println("消费者无法消费消息时调用，如队列被删除");
        });
    }
}
</code></pre>











<h2 id="惰性队列："><a href="#惰性队列：" class="headerlink" title="惰性队列："></a>惰性队列：</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消 费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持 更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致 使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p>
<p>默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留 一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的 时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候</p>
<h3 id="两种模式："><a href="#两种模式：" class="headerlink" title="两种模式："></a>两种模式：</h3><p>队列具备两种模式：default 和 lazy。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy（网页） 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy（网页） 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p>
<p>在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。</p>
<p>下面示 例中演示了一个惰性队列的声明细节：</p>
<pre class="language-none"><code class="language-none">Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();
args.put("x-queue-mode", "lazy");
channel.queueDeclare("myqueue", false, false, false, args);
</code></pre>

<h3 id="内存开销对比"><a href="#内存开销对比" class="headerlink" title="内存开销对比"></a>内存开销对比</h3><p><img src="https://s2.loli.net/2022/04/14/r2WuKcC86kV7Rb3.png" alt="image-20220414175443632"></p>
<p>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB（这是因为存储的时持平上的索引而不是真正的消息）</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Study Hard</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://studyhardya.github.io/2022/03/25/RabiitMQ/">https://studyhardya.github.io/2022/03/25/RabiitMQ/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Study Hard</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/java/">
                                    <span class="chip bg-color">java</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>
<!-- 默认的 -->
<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<!-- 修改的 -->
<!-- <div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div> -->

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'DG3oz2msbm23K7Jc3TzqbIz0-gzGzoHsz',
        appKey: 'lr9NGqTTn4bG8DCFVxxhMhlr',
        notify: 'true' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: 'monsterid',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '没有理由,开团！！！'
    });
</script>




<style>


/* 卡片式背景 */
#vcomments .vcards .vcard {
    padding: 15px 20px 0 20px;
    border-radius: 10px;
    margin-bottom: 15px;
    box-shadow: 0 0 4px 1px rgba(0, 0, 0, .12);
    transition: all .3s
}
#vcomments .vcards .vcard:hover {
    box-shadow: 0 0 8px 3px rgba(0, 0, 0, .12)
}
#vcomments .vcards .vcard .vh .vcard {
    border: none;
    box-shadow: none;
}


    
/*鼠标放置头像旋转*/
img.vimg {
    /* 旋转时间为 1s */
    transition: all 1s
}
img.vimg:hover {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
}


/*===========背景图输入判断=========*/
#veditor:focus {
    background-position-y: 200px;
    transition: all 0.2s ease-in-out 0s;
}


/*==========修改评论框样式===========start====*/
.v .vwrap {
    padding: 0 0 20px;
}
/*内容框高度*/
.v .veditor {
    min-height: 7rem;
    resize: none;
}
/*==========修改评论框样式===========end======*/



/*头部空白栏高度*/
.valine-card .card-content {
    padding: 20px 20px 5px 20px;
}

/* valine 评论框增加背景图片 */
#vcomments textarea {
    /*背景图贴边*/
    margin-top: -30px;
    box-sizing: border-box;
    background: url("/medias/comment_bg.png") 100% 100% no-repeat;
}



</style>

<script>

    
    // 自定义邮箱审核规则
// document.body.addEventListener('click', function (e) {
//     if (e.target.classList.contains('vsubmit')) {
//         const email = document.querySelector('input[type=email]');
//         const nick = document.querySelector('input[name=nick]');
//         const reg = /^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/;
//         if (!email.value || !nick.value || !reg.test(email.value)) {
//             const str = `<div class="valert text-center"><div class="vtext">请填写正确的昵称和邮箱！</div></div>`;
//             const vmark = document.querySelector('.vmark');
//             vmark.innerHTML = str;
//             vmark.style.display = 'block';
//             setTimeout(function () {
//                 vmark.style.display = 'none';
//                 vmark.innerHTML = '';
//             }, 2500);
//         }
//     }
// })


</script>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/03/29/Vue%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="Vue基本使用">
                        
                        <span class="card-title">Vue基本使用</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-03-28
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Vue/" class="post-category">
                                    Vue
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF/">
                        <span class="chip bg-color">前端</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/03/03/SpringBootSecurity/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="SpringBootSecurity">
                        
                        <span class="card-title">SpringBootSecurity</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-03-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/SpringBoot-Security/" class="post-category">
                                    SpringBoot-Security
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/">
                        <span class="chip bg-color">安全框架</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2023</span>
            
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">97.4k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2022";
                        var startMonth = "1";
                        var startDate = "1";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
                <span id="icp"><img src="/medias/icp.png"
                                    style="vertical-align: text-bottom;"/>
                <a href="/null" target="_blank">赣ICP备2022000911号</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/StudyHardYa" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:3502155084@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=3502155084" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 3502155084" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: "af371656"
        });
        daovoice('update');
    </script>
    

    <!--腾讯兔小巢-->
    
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    
    <!-- 切换页面提示 -->
    <script src="/js/FunnyTitle.js"></script>

    <!-- 烟花爆炸效果 -->
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/fireworks.js"></script>

</body>

</html>
